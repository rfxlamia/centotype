{"$message_type":"diagnostic","message":"unclosed HTML tag `Self`","code":{"code":"rustdoc::invalid_html_tags","explanation":null},"level":"warning","spans":[{"file_name":"platform/src/lib.rs","byte_start":1607,"byte_end":1613,"line_start":1,"line_end":1,"column_start":1608,"column_end":1614,"is_primary":true,"text":[{"text":"//! # Centotype Platform\\n//!\\n//! Platform-specific integrations and optimizations for different operating systems\\n//! and terminal environments. This crate provides:\\n//!\\n//! - Terminal capability detection and optimization\\n//! - OS-specific performance optimizations\\n//! - Cross-platform terminal handling abstractions\\n//! - Hardware detection and feature availability\\n//!\\n//! ## Supported Platforms\\n//!\\n//! - **Linux**: Full support with optimizations for common terminals\\n//! - **macOS**: Native terminal integration with performance tuning\\n//! - **Windows**: Windows Terminal, PowerShell, and cmd.exe support\\n//!\\n//! ## Performance Optimizations\\n//!\\n//! - Terminal-specific render optimizations\\n//! - Platform-native input handling\\n//! - Memory management tuning per OS\\n//! - CPU architecture detection\\n\\npub mod terminal;\\npub mod input;\\npub mod performance;\\npub mod detection;\\n\\n// Re-export main types\\npub use terminal::{TerminalCapabilities, TerminalType, TerminalManager};\\npub use input::{PlatformInput, InputOptimizations};\\npub use performance::{PlatformPerformance, SystemMetrics};\\npub use detection::{PlatformDetector, PlatformInfo, OSType, Architecture};\\n\\nuse centotype_core::types::*;\\nuse std::sync::Arc;\\nuse once_cell::sync::Lazy;\\n\\n/// Main platform manager that coordinates all platform-specific functionality\\npub struct PlatformManager {\\n    info: PlatformInfo,\\n    terminal_caps: TerminalCapabilities,\\n    input_optimizations: InputOptimizations,\\n    performance_settings: PlatformPerformance,\\n}\\n\\nimpl PlatformManager {\\n    pub fn new() -> Result<Self> {\\n        let detector = PlatformDetector::new();\\n        let info = detector.detect_platform()?;\\n        let terminal_caps = detector.detect_terminal_capabilities()?;\\n        let input_optimizations = InputOptimizations::for_platform(&info)?;\\n        let performance_settings = PlatformPerformance::optimize_for_platform(&info)?;\\n\\n        tracing::info!(\\n            \\\"Platform detected: OS={:?}, Terminal={:?}, Arch={:?}\\\",\\n            info.os_type,\\n            terminal_caps.terminal_type,\\n            info.architecture\\n        );\\n\\n        Ok(Self {\\n            info,\\n            terminal_caps,\\n            input_optimizations,\\n            performance_settings,\\n        })\\n    }\\n\\n    pub fn platform_info(&self) -> &PlatformInfo {\\n        &self.info\\n    }\\n\\n    pub fn terminal_capabilities(&self) -> &TerminalCapabilities {\\n        &self.terminal_caps\\n    }\\n\\n    pub fn input_optimizations(&self) -> &InputOptimizations {\\n        &self.input_optimizations\\n    }\\n\\n    pub fn performance_settings(&self) -> &PlatformPerformance {\\n        &self.performance_settings\\n    }\\n\\n    /// Check if the platform meets minimum requirements\\n    pub fn validate_platform(&self) -> PlatformValidation {\\n        let mut issues = Vec::new();\\n        let mut warnings = Vec::new();\\n\\n        // Check terminal capabilities\\n        if !self.terminal_caps.supports_raw_mode {\\n            issues.push(\\\"Terminal does not support raw mode\\\".to_string());\\n        }\\n\\n        if !self.terminal_caps.supports_color {\\n            warnings.push(\\\"Terminal does not support color - using monochrome mode\\\".to_string());\\n        }\\n\\n        // Check performance capabilities\\n        if !self.performance_settings.can_meet_targets {\\n            warnings.push(\\\"Platform may not meet performance targets\\\".to_string());\\n        }\\n\\n        // Check input handling\\n        if !self.input_optimizations.high_precision_timing {\\n            warnings.push(\\\"High precision input timing not available\\\".to_string());\\n        }\\n\\n        PlatformValidation {\\n            is_supported: issues.is_empty(),\\n            issues,\\n            warnings,\\n            recommended_settings: self.get_recommended_settings(),\\n        }\\n    }\\n\\n    fn get_recommended_settings(&self) -> RecommendedSettings {\\n        RecommendedSettings {\\n            use_reduced_effects: !self.performance_settings.can_meet_targets,\\n            buffer_size: self.input_optimizations.recommended_buffer_size,\\n            render_frequency: self.performance_settings.recommended_fps,\\n            memory_limit_mb: self.performance_settings.memory_limit_mb,\\n        }\\n    }\\n\\n    /// Apply platform-specific optimizations\\n    pub fn apply_optimizations(&self) -> Result<()> {\\n        // Apply input optimizations\\n        self.input_optimizations.configure_input_system()?;\\n        \\n        // Apply performance optimizations  \\n        self.performance_settings.configure_performance()?;\\n        \\n        // Configure terminal-specific settings\\n        self.terminal_caps.configure_terminal()?;\\n        \\n        tracing::info!(\\\"Platform optimizations applied successfully\\\");\\n        Ok(())\\n    }\\n\\n    /// Get system resource information\\n    pub fn get_system_metrics(&self) -> SystemMetrics {\\n        self.performance_settings.get_current_metrics()\\n    }\\n\\n    /// Check if graceful degradation is needed\\n    pub fn should_use_fallback_mode(&self) -> bool {\\n        !self.performance_settings.can_meet_targets\\n            || self.terminal_caps.has_limitations()\\n    }\\n\\n    /// Get platform-specific error recovery strategies\\n    pub fn get_error_recovery(&self) -> ErrorRecoveryStrategy {\\n        match self.info.os_type {\\n            OSType::Windows => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: true,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: false,\\n            },\\n            OSType::MacOS | OSType::Linux => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: false,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: true,\\n            },\\n            OSType::Unknown => ErrorRecoveryStrategy::default(),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct PlatformValidation {\\n    pub is_supported: bool,\\n    pub issues: Vec<String>,\\n    pub warnings: Vec<String>,\\n    pub recommended_settings: RecommendedSettings,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct RecommendedSettings {\\n    pub use_reduced_effects: bool,\\n    pub buffer_size: usize,\\n    pub render_frequency: u32,\\n    pub memory_limit_mb: u64,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct ErrorRecoveryStrategy {\\n    pub restore_console_mode: bool,\\n    pub flush_input_buffer: bool,\\n    pub reset_cursor_visibility: bool,\\n    pub clear_screen_on_exit: bool,\\n}\\n\\nimpl Default for ErrorRecoveryStrategy {\\n    fn default() -> Self {\\n        Self {\\n            restore_console_mode: true,\\n            flush_input_buffer: true,\\n            reset_cursor_visibility: true,\\n            clear_screen_on_exit: true,\\n        }\\n    }\\n}\\n\\n/// Global platform manager instance\\nstatic PLATFORM_MANAGER: Lazy<Arc<PlatformManager>> = Lazy::new(|| {\\n    Arc::new(PlatformManager::new().expect(\\\"Failed to initialize platform manager\\\"))\\n});\\n\\n/// Get the global platform manager instance\\npub fn get_platform_manager() -> Arc<PlatformManager> {\\n    Arc::clone(&PLATFORM_MANAGER)\\n}\\n\\nimpl Default for PlatformManager {\\n    fn default() -> Self {\\n        Self::new().expect(\\\"Failed to create default platform manager\\\")\\n    }\\n}","highlight_start":1608,"highlight_end":1614}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(rustdoc::invalid_html_tags)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"try marking as source code","code":null,"level":"help","spans":[{"file_name":"platform/src/lib.rs","byte_start":1601,"byte_end":1601,"line_start":1,"line_end":1,"column_start":1602,"column_end":1602,"is_primary":true,"text":[{"text":"//! # Centotype Platform\\n//!\\n//! Platform-specific integrations and optimizations for different operating systems\\n//! and terminal environments. This crate provides:\\n//!\\n//! - Terminal capability detection and optimization\\n//! - OS-specific performance optimizations\\n//! - Cross-platform terminal handling abstractions\\n//! - Hardware detection and feature availability\\n//!\\n//! ## Supported Platforms\\n//!\\n//! - **Linux**: Full support with optimizations for common terminals\\n//! - **macOS**: Native terminal integration with performance tuning\\n//! - **Windows**: Windows Terminal, PowerShell, and cmd.exe support\\n//!\\n//! ## Performance Optimizations\\n//!\\n//! - Terminal-specific render optimizations\\n//! - Platform-native input handling\\n//! - Memory management tuning per OS\\n//! - CPU architecture detection\\n\\npub mod terminal;\\npub mod input;\\npub mod performance;\\npub mod detection;\\n\\n// Re-export main types\\npub use terminal::{TerminalCapabilities, TerminalType, TerminalManager};\\npub use input::{PlatformInput, InputOptimizations};\\npub use performance::{PlatformPerformance, SystemMetrics};\\npub use detection::{PlatformDetector, PlatformInfo, OSType, Architecture};\\n\\nuse centotype_core::types::*;\\nuse std::sync::Arc;\\nuse once_cell::sync::Lazy;\\n\\n/// Main platform manager that coordinates all platform-specific functionality\\npub struct PlatformManager {\\n    info: PlatformInfo,\\n    terminal_caps: TerminalCapabilities,\\n    input_optimizations: InputOptimizations,\\n    performance_settings: PlatformPerformance,\\n}\\n\\nimpl PlatformManager {\\n    pub fn new() -> Result<Self> {\\n        let detector = PlatformDetector::new();\\n        let info = detector.detect_platform()?;\\n        let terminal_caps = detector.detect_terminal_capabilities()?;\\n        let input_optimizations = InputOptimizations::for_platform(&info)?;\\n        let performance_settings = PlatformPerformance::optimize_for_platform(&info)?;\\n\\n        tracing::info!(\\n            \\\"Platform detected: OS={:?}, Terminal={:?}, Arch={:?}\\\",\\n            info.os_type,\\n            terminal_caps.terminal_type,\\n            info.architecture\\n        );\\n\\n        Ok(Self {\\n            info,\\n            terminal_caps,\\n            input_optimizations,\\n            performance_settings,\\n        })\\n    }\\n\\n    pub fn platform_info(&self) -> &PlatformInfo {\\n        &self.info\\n    }\\n\\n    pub fn terminal_capabilities(&self) -> &TerminalCapabilities {\\n        &self.terminal_caps\\n    }\\n\\n    pub fn input_optimizations(&self) -> &InputOptimizations {\\n        &self.input_optimizations\\n    }\\n\\n    pub fn performance_settings(&self) -> &PlatformPerformance {\\n        &self.performance_settings\\n    }\\n\\n    /// Check if the platform meets minimum requirements\\n    pub fn validate_platform(&self) -> PlatformValidation {\\n        let mut issues = Vec::new();\\n        let mut warnings = Vec::new();\\n\\n        // Check terminal capabilities\\n        if !self.terminal_caps.supports_raw_mode {\\n            issues.push(\\\"Terminal does not support raw mode\\\".to_string());\\n        }\\n\\n        if !self.terminal_caps.supports_color {\\n            warnings.push(\\\"Terminal does not support color - using monochrome mode\\\".to_string());\\n        }\\n\\n        // Check performance capabilities\\n        if !self.performance_settings.can_meet_targets {\\n            warnings.push(\\\"Platform may not meet performance targets\\\".to_string());\\n        }\\n\\n        // Check input handling\\n        if !self.input_optimizations.high_precision_timing {\\n            warnings.push(\\\"High precision input timing not available\\\".to_string());\\n        }\\n\\n        PlatformValidation {\\n            is_supported: issues.is_empty(),\\n            issues,\\n            warnings,\\n            recommended_settings: self.get_recommended_settings(),\\n        }\\n    }\\n\\n    fn get_recommended_settings(&self) -> RecommendedSettings {\\n        RecommendedSettings {\\n            use_reduced_effects: !self.performance_settings.can_meet_targets,\\n            buffer_size: self.input_optimizations.recommended_buffer_size,\\n            render_frequency: self.performance_settings.recommended_fps,\\n            memory_limit_mb: self.performance_settings.memory_limit_mb,\\n        }\\n    }\\n\\n    /// Apply platform-specific optimizations\\n    pub fn apply_optimizations(&self) -> Result<()> {\\n        // Apply input optimizations\\n        self.input_optimizations.configure_input_system()?;\\n        \\n        // Apply performance optimizations  \\n        self.performance_settings.configure_performance()?;\\n        \\n        // Configure terminal-specific settings\\n        self.terminal_caps.configure_terminal()?;\\n        \\n        tracing::info!(\\\"Platform optimizations applied successfully\\\");\\n        Ok(())\\n    }\\n\\n    /// Get system resource information\\n    pub fn get_system_metrics(&self) -> SystemMetrics {\\n        self.performance_settings.get_current_metrics()\\n    }\\n\\n    /// Check if graceful degradation is needed\\n    pub fn should_use_fallback_mode(&self) -> bool {\\n        !self.performance_settings.can_meet_targets\\n            || self.terminal_caps.has_limitations()\\n    }\\n\\n    /// Get platform-specific error recovery strategies\\n    pub fn get_error_recovery(&self) -> ErrorRecoveryStrategy {\\n        match self.info.os_type {\\n            OSType::Windows => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: true,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: false,\\n            },\\n            OSType::MacOS | OSType::Linux => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: false,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: true,\\n            },\\n            OSType::Unknown => ErrorRecoveryStrategy::default(),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct PlatformValidation {\\n    pub is_supported: bool,\\n    pub issues: Vec<String>,\\n    pub warnings: Vec<String>,\\n    pub recommended_settings: RecommendedSettings,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct RecommendedSettings {\\n    pub use_reduced_effects: bool,\\n    pub buffer_size: usize,\\n    pub render_frequency: u32,\\n    pub memory_limit_mb: u64,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct ErrorRecoveryStrategy {\\n    pub restore_console_mode: bool,\\n    pub flush_input_buffer: bool,\\n    pub reset_cursor_visibility: bool,\\n    pub clear_screen_on_exit: bool,\\n}\\n\\nimpl Default for ErrorRecoveryStrategy {\\n    fn default() -> Self {\\n        Self {\\n            restore_console_mode: true,\\n            flush_input_buffer: true,\\n            reset_cursor_visibility: true,\\n            clear_screen_on_exit: true,\\n        }\\n    }\\n}\\n\\n/// Global platform manager instance\\nstatic PLATFORM_MANAGER: Lazy<Arc<PlatformManager>> = Lazy::new(|| {\\n    Arc::new(PlatformManager::new().expect(\\\"Failed to initialize platform manager\\\"))\\n});\\n\\n/// Get the global platform manager instance\\npub fn get_platform_manager() -> Arc<PlatformManager> {\\n    Arc::clone(&PLATFORM_MANAGER)\\n}\\n\\nimpl Default for PlatformManager {\\n    fn default() -> Self {\\n        Self::new().expect(\\\"Failed to create default platform manager\\\")\\n    }\\n}","highlight_start":1602,"highlight_end":1602}],"label":null,"suggested_replacement":"`","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"platform/src/lib.rs","byte_start":1613,"byte_end":1613,"line_start":1,"line_end":1,"column_start":1614,"column_end":1614,"is_primary":true,"text":[{"text":"//! # Centotype Platform\\n//!\\n//! Platform-specific integrations and optimizations for different operating systems\\n//! and terminal environments. This crate provides:\\n//!\\n//! - Terminal capability detection and optimization\\n//! - OS-specific performance optimizations\\n//! - Cross-platform terminal handling abstractions\\n//! - Hardware detection and feature availability\\n//!\\n//! ## Supported Platforms\\n//!\\n//! - **Linux**: Full support with optimizations for common terminals\\n//! - **macOS**: Native terminal integration with performance tuning\\n//! - **Windows**: Windows Terminal, PowerShell, and cmd.exe support\\n//!\\n//! ## Performance Optimizations\\n//!\\n//! - Terminal-specific render optimizations\\n//! - Platform-native input handling\\n//! - Memory management tuning per OS\\n//! - CPU architecture detection\\n\\npub mod terminal;\\npub mod input;\\npub mod performance;\\npub mod detection;\\n\\n// Re-export main types\\npub use terminal::{TerminalCapabilities, TerminalType, TerminalManager};\\npub use input::{PlatformInput, InputOptimizations};\\npub use performance::{PlatformPerformance, SystemMetrics};\\npub use detection::{PlatformDetector, PlatformInfo, OSType, Architecture};\\n\\nuse centotype_core::types::*;\\nuse std::sync::Arc;\\nuse once_cell::sync::Lazy;\\n\\n/// Main platform manager that coordinates all platform-specific functionality\\npub struct PlatformManager {\\n    info: PlatformInfo,\\n    terminal_caps: TerminalCapabilities,\\n    input_optimizations: InputOptimizations,\\n    performance_settings: PlatformPerformance,\\n}\\n\\nimpl PlatformManager {\\n    pub fn new() -> Result<Self> {\\n        let detector = PlatformDetector::new();\\n        let info = detector.detect_platform()?;\\n        let terminal_caps = detector.detect_terminal_capabilities()?;\\n        let input_optimizations = InputOptimizations::for_platform(&info)?;\\n        let performance_settings = PlatformPerformance::optimize_for_platform(&info)?;\\n\\n        tracing::info!(\\n            \\\"Platform detected: OS={:?}, Terminal={:?}, Arch={:?}\\\",\\n            info.os_type,\\n            terminal_caps.terminal_type,\\n            info.architecture\\n        );\\n\\n        Ok(Self {\\n            info,\\n            terminal_caps,\\n            input_optimizations,\\n            performance_settings,\\n        })\\n    }\\n\\n    pub fn platform_info(&self) -> &PlatformInfo {\\n        &self.info\\n    }\\n\\n    pub fn terminal_capabilities(&self) -> &TerminalCapabilities {\\n        &self.terminal_caps\\n    }\\n\\n    pub fn input_optimizations(&self) -> &InputOptimizations {\\n        &self.input_optimizations\\n    }\\n\\n    pub fn performance_settings(&self) -> &PlatformPerformance {\\n        &self.performance_settings\\n    }\\n\\n    /// Check if the platform meets minimum requirements\\n    pub fn validate_platform(&self) -> PlatformValidation {\\n        let mut issues = Vec::new();\\n        let mut warnings = Vec::new();\\n\\n        // Check terminal capabilities\\n        if !self.terminal_caps.supports_raw_mode {\\n            issues.push(\\\"Terminal does not support raw mode\\\".to_string());\\n        }\\n\\n        if !self.terminal_caps.supports_color {\\n            warnings.push(\\\"Terminal does not support color - using monochrome mode\\\".to_string());\\n        }\\n\\n        // Check performance capabilities\\n        if !self.performance_settings.can_meet_targets {\\n            warnings.push(\\\"Platform may not meet performance targets\\\".to_string());\\n        }\\n\\n        // Check input handling\\n        if !self.input_optimizations.high_precision_timing {\\n            warnings.push(\\\"High precision input timing not available\\\".to_string());\\n        }\\n\\n        PlatformValidation {\\n            is_supported: issues.is_empty(),\\n            issues,\\n            warnings,\\n            recommended_settings: self.get_recommended_settings(),\\n        }\\n    }\\n\\n    fn get_recommended_settings(&self) -> RecommendedSettings {\\n        RecommendedSettings {\\n            use_reduced_effects: !self.performance_settings.can_meet_targets,\\n            buffer_size: self.input_optimizations.recommended_buffer_size,\\n            render_frequency: self.performance_settings.recommended_fps,\\n            memory_limit_mb: self.performance_settings.memory_limit_mb,\\n        }\\n    }\\n\\n    /// Apply platform-specific optimizations\\n    pub fn apply_optimizations(&self) -> Result<()> {\\n        // Apply input optimizations\\n        self.input_optimizations.configure_input_system()?;\\n        \\n        // Apply performance optimizations  \\n        self.performance_settings.configure_performance()?;\\n        \\n        // Configure terminal-specific settings\\n        self.terminal_caps.configure_terminal()?;\\n        \\n        tracing::info!(\\\"Platform optimizations applied successfully\\\");\\n        Ok(())\\n    }\\n\\n    /// Get system resource information\\n    pub fn get_system_metrics(&self) -> SystemMetrics {\\n        self.performance_settings.get_current_metrics()\\n    }\\n\\n    /// Check if graceful degradation is needed\\n    pub fn should_use_fallback_mode(&self) -> bool {\\n        !self.performance_settings.can_meet_targets\\n            || self.terminal_caps.has_limitations()\\n    }\\n\\n    /// Get platform-specific error recovery strategies\\n    pub fn get_error_recovery(&self) -> ErrorRecoveryStrategy {\\n        match self.info.os_type {\\n            OSType::Windows => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: true,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: false,\\n            },\\n            OSType::MacOS | OSType::Linux => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: false,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: true,\\n            },\\n            OSType::Unknown => ErrorRecoveryStrategy::default(),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct PlatformValidation {\\n    pub is_supported: bool,\\n    pub issues: Vec<String>,\\n    pub warnings: Vec<String>,\\n    pub recommended_settings: RecommendedSettings,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct RecommendedSettings {\\n    pub use_reduced_effects: bool,\\n    pub buffer_size: usize,\\n    pub render_frequency: u32,\\n    pub memory_limit_mb: u64,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct ErrorRecoveryStrategy {\\n    pub restore_console_mode: bool,\\n    pub flush_input_buffer: bool,\\n    pub reset_cursor_visibility: bool,\\n    pub clear_screen_on_exit: bool,\\n}\\n\\nimpl Default for ErrorRecoveryStrategy {\\n    fn default() -> Self {\\n        Self {\\n            restore_console_mode: true,\\n            flush_input_buffer: true,\\n            reset_cursor_visibility: true,\\n            clear_screen_on_exit: true,\\n        }\\n    }\\n}\\n\\n/// Global platform manager instance\\nstatic PLATFORM_MANAGER: Lazy<Arc<PlatformManager>> = Lazy::new(|| {\\n    Arc::new(PlatformManager::new().expect(\\\"Failed to initialize platform manager\\\"))\\n});\\n\\n/// Get the global platform manager instance\\npub fn get_platform_manager() -> Arc<PlatformManager> {\\n    Arc::clone(&PLATFORM_MANAGER)\\n}\\n\\nimpl Default for PlatformManager {\\n    fn default() -> Self {\\n        Self::new().expect(\\\"Failed to create default platform manager\\\")\\n    }\\n}","highlight_start":1614,"highlight_end":1614}],"label":null,"suggested_replacement":"`","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unclosed HTML tag `Self`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mplatform/src/lib.rs:1:1608\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mrmance,\\n}\\n\\nimpl PlatformManager {\\n    pub fn new() -> Result<Self> {\\n        let detector = PlatformDetector::new();\\n        let\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(rustdoc::invalid_html_tags)]` on by default\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try marking as source code\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m//! # Centotype Platform\\n//!\\n//! Platform-specific integrations and optimizations for different operating systems\\n//! and terminal environments. This crate provides:\\n//!\\n//! - Terminal capability detection and optimization\\n//! - OS-specific performance optimizations\\n//! - Cross-platform terminal handling abstractions\\n//! - Hardware detection and feature availability\\n//!\\n//! ## Supported Platforms\\n//!\\n//! - **Linux**: Full support with optimizations for common terminals\\n//! - **macOS**: Native terminal integration with performance tuning\\n//! - **Windows**: Windows Terminal, PowerShell, and cmd.exe support\\n//!\\n//! ## Performance Optimizations\\n//!\\n//! - Terminal-specific render optimizations\\n//! - Platform-native input handling\\n//! - Memory management tuning per OS\\n//! - CPU architecture detection\\n\\npub mod terminal;\\npub mod input;\\npub mod performance;\\npub mod detection;\\n\\n// Re-export main types\\npub use terminal::{TerminalCapabilities, TerminalType, TerminalManager};\\npub use input::{PlatformInput, InputOptimizations};\\npub use performance::{PlatformPerformance, SystemMetrics};\\npub use detection::{PlatformDetector, PlatformInfo, OSType, Architecture};\\n\\nuse centotype_core::types::*;\\nuse std::sync::Arc;\\nuse once_cell::sync::Lazy;\\n\\n/// Main platform manager that coordinates all platform-specific functionality\\npub struct PlatformManager {\\n    info: PlatformInfo,\\n    terminal_caps: TerminalCapabilities,\\n    input_optimizations: InputOptimizations,\\n    performance_settings: PlatformPerformance,\\n}\\n\\nimpl PlatformManager {\\n    pub fn new() -> \u001b[0m\u001b[0m\u001b[38;5;10m`\u001b[0m\u001b[0mResult<Self>\u001b[0m\u001b[0m\u001b[38;5;10m`\u001b[0m\u001b[0m {\\n        let detector = PlatformDetector::new();\\n        let info = detector.detect_platform()?;\\n        let terminal_caps = detector.detect_terminal_capabilities()?;\\n        let input_optimizations = InputOptimizations::for_platform(&info)?;\\n        let performance_settings = PlatformPerformance::optimize_for_platform(&info)?;\\n\\n        tracing::info!(\\n            \\\"Platform detected: OS={:?}, Terminal={:?}, Arch={:?}\\\",\\n            info.os_type,\\n            terminal_caps.terminal_type,\\n            info.architecture\\n        );\\n\\n        Ok(Self {\\n            info,\\n            terminal_caps,\\n            input_optimizations,\\n            performance_settings,\\n        })\\n    }\\n\\n    pub fn platform_info(&self) -> &PlatformInfo {\\n        &self.info\\n    }\\n\\n    pub fn terminal_capabilities(&self) -> &TerminalCapabilities {\\n        &self.terminal_caps\\n    }\\n\\n    pub fn input_optimizations(&self) -> &InputOptimizations {\\n        &self.input_optimizations\\n    }\\n\\n    pub fn performance_settings(&self) -> &PlatformPerformance {\\n        &self.performance_settings\\n    }\\n\\n    /// Check if the platform meets minimum requirements\\n    pub fn validate_platform(&self) -> PlatformValidation {\\n        let mut issues = Vec::new();\\n        let mut warnings = Vec::new();\\n\\n        // Check terminal capabilities\\n        if !self.terminal_caps.supports_raw_mode {\\n            issues.push(\\\"Terminal does not support raw mode\\\".to_string());\\n        }\\n\\n        if !self.terminal_caps.supports_color {\\n            warnings.push(\\\"Terminal does not support color - using monochrome mode\\\".to_string());\\n        }\\n\\n        // Check performance capabilities\\n        if !self.performance_settings.can_meet_targets {\\n            warnings.push(\\\"Platform may not meet performance targets\\\".to_string());\\n        }\\n\\n        // Check input handling\\n        if !self.input_optimizations.high_precision_timing {\\n            warnings.push(\\\"High precision input timing not available\\\".to_string());\\n        }\\n\\n        PlatformValidation {\\n            is_supported: issues.is_empty(),\\n            issues,\\n            warnings,\\n            recommended_settings: self.get_recommended_settings(),\\n        }\\n    }\\n\\n    fn get_recommended_settings(&self) -> RecommendedSettings {\\n        RecommendedSettings {\\n            use_reduced_effects: !self.performance_settings.can_meet_targets,\\n            buffer_size: self.input_optimizations.recommended_buffer_size,\\n            render_frequency: self.performance_settings.recommended_fps,\\n            memory_limit_mb: self.performance_settings.memory_limit_mb,\\n        }\\n    }\\n\\n    /// Apply platform-specific optimizations\\n    pub fn apply_optimizations(&self) -> Result<()> {\\n        // Apply input optimizations\\n        self.input_optimizations.configure_input_system()?;\\n        \\n        // Apply performance optimizations  \\n        self.performance_settings.configure_performance()?;\\n        \\n        // Configure terminal-specific settings\\n        self.terminal_caps.configure_terminal()?;\\n        \\n        tracing::info!(\\\"Platform optimizations applied successfully\\\");\\n        Ok(())\\n    }\\n\\n    /// Get system resource information\\n    pub fn get_system_metrics(&self) -> SystemMetrics {\\n        self.performance_settings.get_current_metrics()\\n    }\\n\\n    /// Check if graceful degradation is needed\\n    pub fn should_use_fallback_mode(&self) -> bool {\\n        !self.performance_settings.can_meet_targets\\n            || self.terminal_caps.has_limitations()\\n    }\\n\\n    /// Get platform-specific error recovery strategies\\n    pub fn get_error_recovery(&self) -> ErrorRecoveryStrategy {\\n        match self.info.os_type {\\n            OSType::Windows => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: true,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: false,\\n            },\\n            OSType::MacOS | OSType::Linux => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: false,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: true,\\n            },\\n            OSType::Unknown => ErrorRecoveryStrategy::default(),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct PlatformValidation {\\n    pub is_supported: bool,\\n    pub issues: Vec<String>,\\n    pub warnings: Vec<String>,\\n    pub recommended_settings: RecommendedSettings,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct RecommendedSettings {\\n    pub use_reduced_effects: bool,\\n    pub buffer_size: usize,\\n    pub render_frequency: u32,\\n    pub memory_limit_mb: u64,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct ErrorRecoveryStrategy {\\n    pub restore_console_mode: bool,\\n    pub flush_input_buffer: bool,\\n    pub reset_cursor_visibility: bool,\\n    pub clear_screen_on_exit: bool,\\n}\\n\\nimpl Default for ErrorRecoveryStrategy {\\n    fn default() -> Self {\\n        Self {\\n            restore_console_mode: true,\\n            flush_input_buffer: true,\\n            reset_cursor_visibility: true,\\n            clear_screen_on_exit: true,\\n        }\\n    }\\n}\\n\\n/// Global platform manager instance\\nstatic PLATFORM_MANAGER: Lazy<Arc<PlatformManager>> = Lazy::new(|| {\\n    Arc::new(PlatformManager::new().expect(\\\"Failed to initialize platform manager\\\"))\\n});\\n\\n/// Get the global platform manager instance\\npub fn get_platform_manager() -> Arc<PlatformManager> {\\n    Arc::clone(&PLATFORM_MANAGER)\\n}\\n\\nimpl Default for PlatformManager {\\n    fn default() -> Self {\\n        Self::new().expect(\\\"Failed to create default platform manager\\\")\\n    }\\n}\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unclosed HTML tag `String`","code":{"code":"rustdoc::invalid_html_tags","explanation":null},"level":"warning","spans":[{"file_name":"platform/src/lib.rs","byte_start":6085,"byte_end":6093,"line_start":1,"line_end":1,"column_start":6086,"column_end":6094,"is_primary":true,"text":[{"text":"//! # Centotype Platform\\n//!\\n//! Platform-specific integrations and optimizations for different operating systems\\n//! and terminal environments. This crate provides:\\n//!\\n//! - Terminal capability detection and optimization\\n//! - OS-specific performance optimizations\\n//! - Cross-platform terminal handling abstractions\\n//! - Hardware detection and feature availability\\n//!\\n//! ## Supported Platforms\\n//!\\n//! - **Linux**: Full support with optimizations for common terminals\\n//! - **macOS**: Native terminal integration with performance tuning\\n//! - **Windows**: Windows Terminal, PowerShell, and cmd.exe support\\n//!\\n//! ## Performance Optimizations\\n//!\\n//! - Terminal-specific render optimizations\\n//! - Platform-native input handling\\n//! - Memory management tuning per OS\\n//! - CPU architecture detection\\n\\npub mod terminal;\\npub mod input;\\npub mod performance;\\npub mod detection;\\n\\n// Re-export main types\\npub use terminal::{TerminalCapabilities, TerminalType, TerminalManager};\\npub use input::{PlatformInput, InputOptimizations};\\npub use performance::{PlatformPerformance, SystemMetrics};\\npub use detection::{PlatformDetector, PlatformInfo, OSType, Architecture};\\n\\nuse centotype_core::types::*;\\nuse std::sync::Arc;\\nuse once_cell::sync::Lazy;\\n\\n/// Main platform manager that coordinates all platform-specific functionality\\npub struct PlatformManager {\\n    info: PlatformInfo,\\n    terminal_caps: TerminalCapabilities,\\n    input_optimizations: InputOptimizations,\\n    performance_settings: PlatformPerformance,\\n}\\n\\nimpl PlatformManager {\\n    pub fn new() -> Result<Self> {\\n        let detector = PlatformDetector::new();\\n        let info = detector.detect_platform()?;\\n        let terminal_caps = detector.detect_terminal_capabilities()?;\\n        let input_optimizations = InputOptimizations::for_platform(&info)?;\\n        let performance_settings = PlatformPerformance::optimize_for_platform(&info)?;\\n\\n        tracing::info!(\\n            \\\"Platform detected: OS={:?}, Terminal={:?}, Arch={:?}\\\",\\n            info.os_type,\\n            terminal_caps.terminal_type,\\n            info.architecture\\n        );\\n\\n        Ok(Self {\\n            info,\\n            terminal_caps,\\n            input_optimizations,\\n            performance_settings,\\n        })\\n    }\\n\\n    pub fn platform_info(&self) -> &PlatformInfo {\\n        &self.info\\n    }\\n\\n    pub fn terminal_capabilities(&self) -> &TerminalCapabilities {\\n        &self.terminal_caps\\n    }\\n\\n    pub fn input_optimizations(&self) -> &InputOptimizations {\\n        &self.input_optimizations\\n    }\\n\\n    pub fn performance_settings(&self) -> &PlatformPerformance {\\n        &self.performance_settings\\n    }\\n\\n    /// Check if the platform meets minimum requirements\\n    pub fn validate_platform(&self) -> PlatformValidation {\\n        let mut issues = Vec::new();\\n        let mut warnings = Vec::new();\\n\\n        // Check terminal capabilities\\n        if !self.terminal_caps.supports_raw_mode {\\n            issues.push(\\\"Terminal does not support raw mode\\\".to_string());\\n        }\\n\\n        if !self.terminal_caps.supports_color {\\n            warnings.push(\\\"Terminal does not support color - using monochrome mode\\\".to_string());\\n        }\\n\\n        // Check performance capabilities\\n        if !self.performance_settings.can_meet_targets {\\n            warnings.push(\\\"Platform may not meet performance targets\\\".to_string());\\n        }\\n\\n        // Check input handling\\n        if !self.input_optimizations.high_precision_timing {\\n            warnings.push(\\\"High precision input timing not available\\\".to_string());\\n        }\\n\\n        PlatformValidation {\\n            is_supported: issues.is_empty(),\\n            issues,\\n            warnings,\\n            recommended_settings: self.get_recommended_settings(),\\n        }\\n    }\\n\\n    fn get_recommended_settings(&self) -> RecommendedSettings {\\n        RecommendedSettings {\\n            use_reduced_effects: !self.performance_settings.can_meet_targets,\\n            buffer_size: self.input_optimizations.recommended_buffer_size,\\n            render_frequency: self.performance_settings.recommended_fps,\\n            memory_limit_mb: self.performance_settings.memory_limit_mb,\\n        }\\n    }\\n\\n    /// Apply platform-specific optimizations\\n    pub fn apply_optimizations(&self) -> Result<()> {\\n        // Apply input optimizations\\n        self.input_optimizations.configure_input_system()?;\\n        \\n        // Apply performance optimizations  \\n        self.performance_settings.configure_performance()?;\\n        \\n        // Configure terminal-specific settings\\n        self.terminal_caps.configure_terminal()?;\\n        \\n        tracing::info!(\\\"Platform optimizations applied successfully\\\");\\n        Ok(())\\n    }\\n\\n    /// Get system resource information\\n    pub fn get_system_metrics(&self) -> SystemMetrics {\\n        self.performance_settings.get_current_metrics()\\n    }\\n\\n    /// Check if graceful degradation is needed\\n    pub fn should_use_fallback_mode(&self) -> bool {\\n        !self.performance_settings.can_meet_targets\\n            || self.terminal_caps.has_limitations()\\n    }\\n\\n    /// Get platform-specific error recovery strategies\\n    pub fn get_error_recovery(&self) -> ErrorRecoveryStrategy {\\n        match self.info.os_type {\\n            OSType::Windows => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: true,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: false,\\n            },\\n            OSType::MacOS | OSType::Linux => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: false,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: true,\\n            },\\n            OSType::Unknown => ErrorRecoveryStrategy::default(),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct PlatformValidation {\\n    pub is_supported: bool,\\n    pub issues: Vec<String>,\\n    pub warnings: Vec<String>,\\n    pub recommended_settings: RecommendedSettings,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct RecommendedSettings {\\n    pub use_reduced_effects: bool,\\n    pub buffer_size: usize,\\n    pub render_frequency: u32,\\n    pub memory_limit_mb: u64,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct ErrorRecoveryStrategy {\\n    pub restore_console_mode: bool,\\n    pub flush_input_buffer: bool,\\n    pub reset_cursor_visibility: bool,\\n    pub clear_screen_on_exit: bool,\\n}\\n\\nimpl Default for ErrorRecoveryStrategy {\\n    fn default() -> Self {\\n        Self {\\n            restore_console_mode: true,\\n            flush_input_buffer: true,\\n            reset_cursor_visibility: true,\\n            clear_screen_on_exit: true,\\n        }\\n    }\\n}\\n\\n/// Global platform manager instance\\nstatic PLATFORM_MANAGER: Lazy<Arc<PlatformManager>> = Lazy::new(|| {\\n    Arc::new(PlatformManager::new().expect(\\\"Failed to initialize platform manager\\\"))\\n});\\n\\n/// Get the global platform manager instance\\npub fn get_platform_manager() -> Arc<PlatformManager> {\\n    Arc::clone(&PLATFORM_MANAGER)\\n}\\n\\nimpl Default for PlatformManager {\\n    fn default() -> Self {\\n        Self::new().expect(\\\"Failed to create default platform manager\\\")\\n    }\\n}","highlight_start":6086,"highlight_end":6094}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try marking as source code","code":null,"level":"help","spans":[{"file_name":"platform/src/lib.rs","byte_start":6082,"byte_end":6082,"line_start":1,"line_end":1,"column_start":6083,"column_end":6083,"is_primary":true,"text":[{"text":"//! # Centotype Platform\\n//!\\n//! Platform-specific integrations and optimizations for different operating systems\\n//! and terminal environments. This crate provides:\\n//!\\n//! - Terminal capability detection and optimization\\n//! - OS-specific performance optimizations\\n//! - Cross-platform terminal handling abstractions\\n//! - Hardware detection and feature availability\\n//!\\n//! ## Supported Platforms\\n//!\\n//! - **Linux**: Full support with optimizations for common terminals\\n//! - **macOS**: Native terminal integration with performance tuning\\n//! - **Windows**: Windows Terminal, PowerShell, and cmd.exe support\\n//!\\n//! ## Performance Optimizations\\n//!\\n//! - Terminal-specific render optimizations\\n//! - Platform-native input handling\\n//! - Memory management tuning per OS\\n//! - CPU architecture detection\\n\\npub mod terminal;\\npub mod input;\\npub mod performance;\\npub mod detection;\\n\\n// Re-export main types\\npub use terminal::{TerminalCapabilities, TerminalType, TerminalManager};\\npub use input::{PlatformInput, InputOptimizations};\\npub use performance::{PlatformPerformance, SystemMetrics};\\npub use detection::{PlatformDetector, PlatformInfo, OSType, Architecture};\\n\\nuse centotype_core::types::*;\\nuse std::sync::Arc;\\nuse once_cell::sync::Lazy;\\n\\n/// Main platform manager that coordinates all platform-specific functionality\\npub struct PlatformManager {\\n    info: PlatformInfo,\\n    terminal_caps: TerminalCapabilities,\\n    input_optimizations: InputOptimizations,\\n    performance_settings: PlatformPerformance,\\n}\\n\\nimpl PlatformManager {\\n    pub fn new() -> Result<Self> {\\n        let detector = PlatformDetector::new();\\n        let info = detector.detect_platform()?;\\n        let terminal_caps = detector.detect_terminal_capabilities()?;\\n        let input_optimizations = InputOptimizations::for_platform(&info)?;\\n        let performance_settings = PlatformPerformance::optimize_for_platform(&info)?;\\n\\n        tracing::info!(\\n            \\\"Platform detected: OS={:?}, Terminal={:?}, Arch={:?}\\\",\\n            info.os_type,\\n            terminal_caps.terminal_type,\\n            info.architecture\\n        );\\n\\n        Ok(Self {\\n            info,\\n            terminal_caps,\\n            input_optimizations,\\n            performance_settings,\\n        })\\n    }\\n\\n    pub fn platform_info(&self) -> &PlatformInfo {\\n        &self.info\\n    }\\n\\n    pub fn terminal_capabilities(&self) -> &TerminalCapabilities {\\n        &self.terminal_caps\\n    }\\n\\n    pub fn input_optimizations(&self) -> &InputOptimizations {\\n        &self.input_optimizations\\n    }\\n\\n    pub fn performance_settings(&self) -> &PlatformPerformance {\\n        &self.performance_settings\\n    }\\n\\n    /// Check if the platform meets minimum requirements\\n    pub fn validate_platform(&self) -> PlatformValidation {\\n        let mut issues = Vec::new();\\n        let mut warnings = Vec::new();\\n\\n        // Check terminal capabilities\\n        if !self.terminal_caps.supports_raw_mode {\\n            issues.push(\\\"Terminal does not support raw mode\\\".to_string());\\n        }\\n\\n        if !self.terminal_caps.supports_color {\\n            warnings.push(\\\"Terminal does not support color - using monochrome mode\\\".to_string());\\n        }\\n\\n        // Check performance capabilities\\n        if !self.performance_settings.can_meet_targets {\\n            warnings.push(\\\"Platform may not meet performance targets\\\".to_string());\\n        }\\n\\n        // Check input handling\\n        if !self.input_optimizations.high_precision_timing {\\n            warnings.push(\\\"High precision input timing not available\\\".to_string());\\n        }\\n\\n        PlatformValidation {\\n            is_supported: issues.is_empty(),\\n            issues,\\n            warnings,\\n            recommended_settings: self.get_recommended_settings(),\\n        }\\n    }\\n\\n    fn get_recommended_settings(&self) -> RecommendedSettings {\\n        RecommendedSettings {\\n            use_reduced_effects: !self.performance_settings.can_meet_targets,\\n            buffer_size: self.input_optimizations.recommended_buffer_size,\\n            render_frequency: self.performance_settings.recommended_fps,\\n            memory_limit_mb: self.performance_settings.memory_limit_mb,\\n        }\\n    }\\n\\n    /// Apply platform-specific optimizations\\n    pub fn apply_optimizations(&self) -> Result<()> {\\n        // Apply input optimizations\\n        self.input_optimizations.configure_input_system()?;\\n        \\n        // Apply performance optimizations  \\n        self.performance_settings.configure_performance()?;\\n        \\n        // Configure terminal-specific settings\\n        self.terminal_caps.configure_terminal()?;\\n        \\n        tracing::info!(\\\"Platform optimizations applied successfully\\\");\\n        Ok(())\\n    }\\n\\n    /// Get system resource information\\n    pub fn get_system_metrics(&self) -> SystemMetrics {\\n        self.performance_settings.get_current_metrics()\\n    }\\n\\n    /// Check if graceful degradation is needed\\n    pub fn should_use_fallback_mode(&self) -> bool {\\n        !self.performance_settings.can_meet_targets\\n            || self.terminal_caps.has_limitations()\\n    }\\n\\n    /// Get platform-specific error recovery strategies\\n    pub fn get_error_recovery(&self) -> ErrorRecoveryStrategy {\\n        match self.info.os_type {\\n            OSType::Windows => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: true,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: false,\\n            },\\n            OSType::MacOS | OSType::Linux => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: false,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: true,\\n            },\\n            OSType::Unknown => ErrorRecoveryStrategy::default(),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct PlatformValidation {\\n    pub is_supported: bool,\\n    pub issues: Vec<String>,\\n    pub warnings: Vec<String>,\\n    pub recommended_settings: RecommendedSettings,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct RecommendedSettings {\\n    pub use_reduced_effects: bool,\\n    pub buffer_size: usize,\\n    pub render_frequency: u32,\\n    pub memory_limit_mb: u64,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct ErrorRecoveryStrategy {\\n    pub restore_console_mode: bool,\\n    pub flush_input_buffer: bool,\\n    pub reset_cursor_visibility: bool,\\n    pub clear_screen_on_exit: bool,\\n}\\n\\nimpl Default for ErrorRecoveryStrategy {\\n    fn default() -> Self {\\n        Self {\\n            restore_console_mode: true,\\n            flush_input_buffer: true,\\n            reset_cursor_visibility: true,\\n            clear_screen_on_exit: true,\\n        }\\n    }\\n}\\n\\n/// Global platform manager instance\\nstatic PLATFORM_MANAGER: Lazy<Arc<PlatformManager>> = Lazy::new(|| {\\n    Arc::new(PlatformManager::new().expect(\\\"Failed to initialize platform manager\\\"))\\n});\\n\\n/// Get the global platform manager instance\\npub fn get_platform_manager() -> Arc<PlatformManager> {\\n    Arc::clone(&PLATFORM_MANAGER)\\n}\\n\\nimpl Default for PlatformManager {\\n    fn default() -> Self {\\n        Self::new().expect(\\\"Failed to create default platform manager\\\")\\n    }\\n}","highlight_start":6083,"highlight_end":6083}],"label":null,"suggested_replacement":"`","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"platform/src/lib.rs","byte_start":6093,"byte_end":6093,"line_start":1,"line_end":1,"column_start":6094,"column_end":6094,"is_primary":true,"text":[{"text":"//! # Centotype Platform\\n//!\\n//! Platform-specific integrations and optimizations for different operating systems\\n//! and terminal environments. This crate provides:\\n//!\\n//! - Terminal capability detection and optimization\\n//! - OS-specific performance optimizations\\n//! - Cross-platform terminal handling abstractions\\n//! - Hardware detection and feature availability\\n//!\\n//! ## Supported Platforms\\n//!\\n//! - **Linux**: Full support with optimizations for common terminals\\n//! - **macOS**: Native terminal integration with performance tuning\\n//! - **Windows**: Windows Terminal, PowerShell, and cmd.exe support\\n//!\\n//! ## Performance Optimizations\\n//!\\n//! - Terminal-specific render optimizations\\n//! - Platform-native input handling\\n//! - Memory management tuning per OS\\n//! - CPU architecture detection\\n\\npub mod terminal;\\npub mod input;\\npub mod performance;\\npub mod detection;\\n\\n// Re-export main types\\npub use terminal::{TerminalCapabilities, TerminalType, TerminalManager};\\npub use input::{PlatformInput, InputOptimizations};\\npub use performance::{PlatformPerformance, SystemMetrics};\\npub use detection::{PlatformDetector, PlatformInfo, OSType, Architecture};\\n\\nuse centotype_core::types::*;\\nuse std::sync::Arc;\\nuse once_cell::sync::Lazy;\\n\\n/// Main platform manager that coordinates all platform-specific functionality\\npub struct PlatformManager {\\n    info: PlatformInfo,\\n    terminal_caps: TerminalCapabilities,\\n    input_optimizations: InputOptimizations,\\n    performance_settings: PlatformPerformance,\\n}\\n\\nimpl PlatformManager {\\n    pub fn new() -> Result<Self> {\\n        let detector = PlatformDetector::new();\\n        let info = detector.detect_platform()?;\\n        let terminal_caps = detector.detect_terminal_capabilities()?;\\n        let input_optimizations = InputOptimizations::for_platform(&info)?;\\n        let performance_settings = PlatformPerformance::optimize_for_platform(&info)?;\\n\\n        tracing::info!(\\n            \\\"Platform detected: OS={:?}, Terminal={:?}, Arch={:?}\\\",\\n            info.os_type,\\n            terminal_caps.terminal_type,\\n            info.architecture\\n        );\\n\\n        Ok(Self {\\n            info,\\n            terminal_caps,\\n            input_optimizations,\\n            performance_settings,\\n        })\\n    }\\n\\n    pub fn platform_info(&self) -> &PlatformInfo {\\n        &self.info\\n    }\\n\\n    pub fn terminal_capabilities(&self) -> &TerminalCapabilities {\\n        &self.terminal_caps\\n    }\\n\\n    pub fn input_optimizations(&self) -> &InputOptimizations {\\n        &self.input_optimizations\\n    }\\n\\n    pub fn performance_settings(&self) -> &PlatformPerformance {\\n        &self.performance_settings\\n    }\\n\\n    /// Check if the platform meets minimum requirements\\n    pub fn validate_platform(&self) -> PlatformValidation {\\n        let mut issues = Vec::new();\\n        let mut warnings = Vec::new();\\n\\n        // Check terminal capabilities\\n        if !self.terminal_caps.supports_raw_mode {\\n            issues.push(\\\"Terminal does not support raw mode\\\".to_string());\\n        }\\n\\n        if !self.terminal_caps.supports_color {\\n            warnings.push(\\\"Terminal does not support color - using monochrome mode\\\".to_string());\\n        }\\n\\n        // Check performance capabilities\\n        if !self.performance_settings.can_meet_targets {\\n            warnings.push(\\\"Platform may not meet performance targets\\\".to_string());\\n        }\\n\\n        // Check input handling\\n        if !self.input_optimizations.high_precision_timing {\\n            warnings.push(\\\"High precision input timing not available\\\".to_string());\\n        }\\n\\n        PlatformValidation {\\n            is_supported: issues.is_empty(),\\n            issues,\\n            warnings,\\n            recommended_settings: self.get_recommended_settings(),\\n        }\\n    }\\n\\n    fn get_recommended_settings(&self) -> RecommendedSettings {\\n        RecommendedSettings {\\n            use_reduced_effects: !self.performance_settings.can_meet_targets,\\n            buffer_size: self.input_optimizations.recommended_buffer_size,\\n            render_frequency: self.performance_settings.recommended_fps,\\n            memory_limit_mb: self.performance_settings.memory_limit_mb,\\n        }\\n    }\\n\\n    /// Apply platform-specific optimizations\\n    pub fn apply_optimizations(&self) -> Result<()> {\\n        // Apply input optimizations\\n        self.input_optimizations.configure_input_system()?;\\n        \\n        // Apply performance optimizations  \\n        self.performance_settings.configure_performance()?;\\n        \\n        // Configure terminal-specific settings\\n        self.terminal_caps.configure_terminal()?;\\n        \\n        tracing::info!(\\\"Platform optimizations applied successfully\\\");\\n        Ok(())\\n    }\\n\\n    /// Get system resource information\\n    pub fn get_system_metrics(&self) -> SystemMetrics {\\n        self.performance_settings.get_current_metrics()\\n    }\\n\\n    /// Check if graceful degradation is needed\\n    pub fn should_use_fallback_mode(&self) -> bool {\\n        !self.performance_settings.can_meet_targets\\n            || self.terminal_caps.has_limitations()\\n    }\\n\\n    /// Get platform-specific error recovery strategies\\n    pub fn get_error_recovery(&self) -> ErrorRecoveryStrategy {\\n        match self.info.os_type {\\n            OSType::Windows => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: true,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: false,\\n            },\\n            OSType::MacOS | OSType::Linux => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: false,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: true,\\n            },\\n            OSType::Unknown => ErrorRecoveryStrategy::default(),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct PlatformValidation {\\n    pub is_supported: bool,\\n    pub issues: Vec<String>,\\n    pub warnings: Vec<String>,\\n    pub recommended_settings: RecommendedSettings,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct RecommendedSettings {\\n    pub use_reduced_effects: bool,\\n    pub buffer_size: usize,\\n    pub render_frequency: u32,\\n    pub memory_limit_mb: u64,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct ErrorRecoveryStrategy {\\n    pub restore_console_mode: bool,\\n    pub flush_input_buffer: bool,\\n    pub reset_cursor_visibility: bool,\\n    pub clear_screen_on_exit: bool,\\n}\\n\\nimpl Default for ErrorRecoveryStrategy {\\n    fn default() -> Self {\\n        Self {\\n            restore_console_mode: true,\\n            flush_input_buffer: true,\\n            reset_cursor_visibility: true,\\n            clear_screen_on_exit: true,\\n        }\\n    }\\n}\\n\\n/// Global platform manager instance\\nstatic PLATFORM_MANAGER: Lazy<Arc<PlatformManager>> = Lazy::new(|| {\\n    Arc::new(PlatformManager::new().expect(\\\"Failed to initialize platform manager\\\"))\\n});\\n\\n/// Get the global platform manager instance\\npub fn get_platform_manager() -> Arc<PlatformManager> {\\n    Arc::clone(&PLATFORM_MANAGER)\\n}\\n\\nimpl Default for PlatformManager {\\n    fn default() -> Self {\\n        Self::new().expect(\\\"Failed to create default platform manager\\\")\\n    }\\n}","highlight_start":6094,"highlight_end":6094}],"label":null,"suggested_replacement":"`","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unclosed HTML tag `String`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mplatform/src/lib.rs:1:6086\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mmValidation {\\n    pub is_supported: bool,\\n    pub issues: Vec<String>,\\n    pub warnings: Vec<String>,\\n    pub recommended_settings\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                   \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try marking as source code\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m//! # Centotype Platform\\n//!\\n//! Platform-specific integrations and optimizations for different operating systems\\n//! and terminal environments. This crate provides:\\n//!\\n//! - Terminal capability detection and optimization\\n//! - OS-specific performance optimizations\\n//! - Cross-platform terminal handling abstractions\\n//! - Hardware detection and feature availability\\n//!\\n//! ## Supported Platforms\\n//!\\n//! - **Linux**: Full support with optimizations for common terminals\\n//! - **macOS**: Native terminal integration with performance tuning\\n//! - **Windows**: Windows Terminal, PowerShell, and cmd.exe support\\n//!\\n//! ## Performance Optimizations\\n//!\\n//! - Terminal-specific render optimizations\\n//! - Platform-native input handling\\n//! - Memory management tuning per OS\\n//! - CPU architecture detection\\n\\npub mod terminal;\\npub mod input;\\npub mod performance;\\npub mod detection;\\n\\n// Re-export main types\\npub use terminal::{TerminalCapabilities, TerminalType, TerminalManager};\\npub use input::{PlatformInput, InputOptimizations};\\npub use performance::{PlatformPerformance, SystemMetrics};\\npub use detection::{PlatformDetector, PlatformInfo, OSType, Architecture};\\n\\nuse centotype_core::types::*;\\nuse std::sync::Arc;\\nuse once_cell::sync::Lazy;\\n\\n/// Main platform manager that coordinates all platform-specific functionality\\npub struct PlatformManager {\\n    info: PlatformInfo,\\n    terminal_caps: TerminalCapabilities,\\n    input_optimizations: InputOptimizations,\\n    performance_settings: PlatformPerformance,\\n}\\n\\nimpl PlatformManager {\\n    pub fn new() -> Result<Self> {\\n        let detector = PlatformDetector::new();\\n        let info = detector.detect_platform()?;\\n        let terminal_caps = detector.detect_terminal_capabilities()?;\\n        let input_optimizations = InputOptimizations::for_platform(&info)?;\\n        let performance_settings = PlatformPerformance::optimize_for_platform(&info)?;\\n\\n        tracing::info!(\\n            \\\"Platform detected: OS={:?}, Terminal={:?}, Arch={:?}\\\",\\n            info.os_type,\\n            terminal_caps.terminal_type,\\n            info.architecture\\n        );\\n\\n        Ok(Self {\\n            info,\\n            terminal_caps,\\n            input_optimizations,\\n            performance_settings,\\n        })\\n    }\\n\\n    pub fn platform_info(&self) -> &PlatformInfo {\\n        &self.info\\n    }\\n\\n    pub fn terminal_capabilities(&self) -> &TerminalCapabilities {\\n        &self.terminal_caps\\n    }\\n\\n    pub fn input_optimizations(&self) -> &InputOptimizations {\\n        &self.input_optimizations\\n    }\\n\\n    pub fn performance_settings(&self) -> &PlatformPerformance {\\n        &self.performance_settings\\n    }\\n\\n    /// Check if the platform meets minimum requirements\\n    pub fn validate_platform(&self) -> PlatformValidation {\\n        let mut issues = Vec::new();\\n        let mut warnings = Vec::new();\\n\\n        // Check terminal capabilities\\n        if !self.terminal_caps.supports_raw_mode {\\n            issues.push(\\\"Terminal does not support raw mode\\\".to_string());\\n        }\\n\\n        if !self.terminal_caps.supports_color {\\n            warnings.push(\\\"Terminal does not support color - using monochrome mode\\\".to_string());\\n        }\\n\\n        // Check performance capabilities\\n        if !self.performance_settings.can_meet_targets {\\n            warnings.push(\\\"Platform may not meet performance targets\\\".to_string());\\n        }\\n\\n        // Check input handling\\n        if !self.input_optimizations.high_precision_timing {\\n            warnings.push(\\\"High precision input timing not available\\\".to_string());\\n        }\\n\\n        PlatformValidation {\\n            is_supported: issues.is_empty(),\\n            issues,\\n            warnings,\\n            recommended_settings: self.get_recommended_settings(),\\n        }\\n    }\\n\\n    fn get_recommended_settings(&self) -> RecommendedSettings {\\n        RecommendedSettings {\\n            use_reduced_effects: !self.performance_settings.can_meet_targets,\\n            buffer_size: self.input_optimizations.recommended_buffer_size,\\n            render_frequency: self.performance_settings.recommended_fps,\\n            memory_limit_mb: self.performance_settings.memory_limit_mb,\\n        }\\n    }\\n\\n    /// Apply platform-specific optimizations\\n    pub fn apply_optimizations(&self) -> Result<()> {\\n        // Apply input optimizations\\n        self.input_optimizations.configure_input_system()?;\\n        \\n        // Apply performance optimizations  \\n        self.performance_settings.configure_performance()?;\\n        \\n        // Configure terminal-specific settings\\n        self.terminal_caps.configure_terminal()?;\\n        \\n        tracing::info!(\\\"Platform optimizations applied successfully\\\");\\n        Ok(())\\n    }\\n\\n    /// Get system resource information\\n    pub fn get_system_metrics(&self) -> SystemMetrics {\\n        self.performance_settings.get_current_metrics()\\n    }\\n\\n    /// Check if graceful degradation is needed\\n    pub fn should_use_fallback_mode(&self) -> bool {\\n        !self.performance_settings.can_meet_targets\\n            || self.terminal_caps.has_limitations()\\n    }\\n\\n    /// Get platform-specific error recovery strategies\\n    pub fn get_error_recovery(&self) -> ErrorRecoveryStrategy {\\n        match self.info.os_type {\\n            OSType::Windows => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: true,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: false,\\n            },\\n            OSType::MacOS | OSType::Linux => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: false,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: true,\\n            },\\n            OSType::Unknown => ErrorRecoveryStrategy::default(),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct PlatformValidation {\\n    pub is_supported: bool,\\n    pub issues: \u001b[0m\u001b[0m\u001b[38;5;10m`\u001b[0m\u001b[0mVec<String>\u001b[0m\u001b[0m\u001b[38;5;10m`\u001b[0m\u001b[0m,\\n    pub warnings: Vec<String>,\\n    pub recommended_settings: RecommendedSettings,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct RecommendedSettings {\\n    pub use_reduced_effects: bool,\\n    pub buffer_size: usize,\\n    pub render_frequency: u32,\\n    pub memory_limit_mb: u64,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct ErrorRecoveryStrategy {\\n    pub restore_console_mode: bool,\\n    pub flush_input_buffer: bool,\\n    pub reset_cursor_visibility: bool,\\n    pub clear_screen_on_exit: bool,\\n}\\n\\nimpl Default for ErrorRecoveryStrategy {\\n    fn default() -> Self {\\n        Self {\\n            restore_console_mode: true,\\n            flush_input_buffer: true,\\n            reset_cursor_visibility: true,\\n            clear_screen_on_exit: true,\\n        }\\n    }\\n}\\n\\n/// Global platform manager instance\\nstatic PLATFORM_MANAGER: Lazy<Arc<PlatformManager>> = Lazy::new(|| {\\n    Arc::new(PlatformManager::new().expect(\\\"Failed to initialize platform manager\\\"))\\n});\\n\\n/// Get the global platform manager instance\\npub fn get_platform_manager() -> Arc<PlatformManager> {\\n    Arc::clone(&PLATFORM_MANAGER)\\n}\\n\\nimpl Default for PlatformManager {\\n    fn default() -> Self {\\n        Self::new().expect(\\\"Failed to create default platform manager\\\")\\n    }\\n}\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unclosed HTML tag `String`","code":{"code":"rustdoc::invalid_html_tags","explanation":null},"level":"warning","spans":[{"file_name":"platform/src/lib.rs","byte_start":6117,"byte_end":6125,"line_start":1,"line_end":1,"column_start":6118,"column_end":6126,"is_primary":true,"text":[{"text":"//! # Centotype Platform\\n//!\\n//! Platform-specific integrations and optimizations for different operating systems\\n//! and terminal environments. This crate provides:\\n//!\\n//! - Terminal capability detection and optimization\\n//! - OS-specific performance optimizations\\n//! - Cross-platform terminal handling abstractions\\n//! - Hardware detection and feature availability\\n//!\\n//! ## Supported Platforms\\n//!\\n//! - **Linux**: Full support with optimizations for common terminals\\n//! - **macOS**: Native terminal integration with performance tuning\\n//! - **Windows**: Windows Terminal, PowerShell, and cmd.exe support\\n//!\\n//! ## Performance Optimizations\\n//!\\n//! - Terminal-specific render optimizations\\n//! - Platform-native input handling\\n//! - Memory management tuning per OS\\n//! - CPU architecture detection\\n\\npub mod terminal;\\npub mod input;\\npub mod performance;\\npub mod detection;\\n\\n// Re-export main types\\npub use terminal::{TerminalCapabilities, TerminalType, TerminalManager};\\npub use input::{PlatformInput, InputOptimizations};\\npub use performance::{PlatformPerformance, SystemMetrics};\\npub use detection::{PlatformDetector, PlatformInfo, OSType, Architecture};\\n\\nuse centotype_core::types::*;\\nuse std::sync::Arc;\\nuse once_cell::sync::Lazy;\\n\\n/// Main platform manager that coordinates all platform-specific functionality\\npub struct PlatformManager {\\n    info: PlatformInfo,\\n    terminal_caps: TerminalCapabilities,\\n    input_optimizations: InputOptimizations,\\n    performance_settings: PlatformPerformance,\\n}\\n\\nimpl PlatformManager {\\n    pub fn new() -> Result<Self> {\\n        let detector = PlatformDetector::new();\\n        let info = detector.detect_platform()?;\\n        let terminal_caps = detector.detect_terminal_capabilities()?;\\n        let input_optimizations = InputOptimizations::for_platform(&info)?;\\n        let performance_settings = PlatformPerformance::optimize_for_platform(&info)?;\\n\\n        tracing::info!(\\n            \\\"Platform detected: OS={:?}, Terminal={:?}, Arch={:?}\\\",\\n            info.os_type,\\n            terminal_caps.terminal_type,\\n            info.architecture\\n        );\\n\\n        Ok(Self {\\n            info,\\n            terminal_caps,\\n            input_optimizations,\\n            performance_settings,\\n        })\\n    }\\n\\n    pub fn platform_info(&self) -> &PlatformInfo {\\n        &self.info\\n    }\\n\\n    pub fn terminal_capabilities(&self) -> &TerminalCapabilities {\\n        &self.terminal_caps\\n    }\\n\\n    pub fn input_optimizations(&self) -> &InputOptimizations {\\n        &self.input_optimizations\\n    }\\n\\n    pub fn performance_settings(&self) -> &PlatformPerformance {\\n        &self.performance_settings\\n    }\\n\\n    /// Check if the platform meets minimum requirements\\n    pub fn validate_platform(&self) -> PlatformValidation {\\n        let mut issues = Vec::new();\\n        let mut warnings = Vec::new();\\n\\n        // Check terminal capabilities\\n        if !self.terminal_caps.supports_raw_mode {\\n            issues.push(\\\"Terminal does not support raw mode\\\".to_string());\\n        }\\n\\n        if !self.terminal_caps.supports_color {\\n            warnings.push(\\\"Terminal does not support color - using monochrome mode\\\".to_string());\\n        }\\n\\n        // Check performance capabilities\\n        if !self.performance_settings.can_meet_targets {\\n            warnings.push(\\\"Platform may not meet performance targets\\\".to_string());\\n        }\\n\\n        // Check input handling\\n        if !self.input_optimizations.high_precision_timing {\\n            warnings.push(\\\"High precision input timing not available\\\".to_string());\\n        }\\n\\n        PlatformValidation {\\n            is_supported: issues.is_empty(),\\n            issues,\\n            warnings,\\n            recommended_settings: self.get_recommended_settings(),\\n        }\\n    }\\n\\n    fn get_recommended_settings(&self) -> RecommendedSettings {\\n        RecommendedSettings {\\n            use_reduced_effects: !self.performance_settings.can_meet_targets,\\n            buffer_size: self.input_optimizations.recommended_buffer_size,\\n            render_frequency: self.performance_settings.recommended_fps,\\n            memory_limit_mb: self.performance_settings.memory_limit_mb,\\n        }\\n    }\\n\\n    /// Apply platform-specific optimizations\\n    pub fn apply_optimizations(&self) -> Result<()> {\\n        // Apply input optimizations\\n        self.input_optimizations.configure_input_system()?;\\n        \\n        // Apply performance optimizations  \\n        self.performance_settings.configure_performance()?;\\n        \\n        // Configure terminal-specific settings\\n        self.terminal_caps.configure_terminal()?;\\n        \\n        tracing::info!(\\\"Platform optimizations applied successfully\\\");\\n        Ok(())\\n    }\\n\\n    /// Get system resource information\\n    pub fn get_system_metrics(&self) -> SystemMetrics {\\n        self.performance_settings.get_current_metrics()\\n    }\\n\\n    /// Check if graceful degradation is needed\\n    pub fn should_use_fallback_mode(&self) -> bool {\\n        !self.performance_settings.can_meet_targets\\n            || self.terminal_caps.has_limitations()\\n    }\\n\\n    /// Get platform-specific error recovery strategies\\n    pub fn get_error_recovery(&self) -> ErrorRecoveryStrategy {\\n        match self.info.os_type {\\n            OSType::Windows => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: true,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: false,\\n            },\\n            OSType::MacOS | OSType::Linux => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: false,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: true,\\n            },\\n            OSType::Unknown => ErrorRecoveryStrategy::default(),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct PlatformValidation {\\n    pub is_supported: bool,\\n    pub issues: Vec<String>,\\n    pub warnings: Vec<String>,\\n    pub recommended_settings: RecommendedSettings,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct RecommendedSettings {\\n    pub use_reduced_effects: bool,\\n    pub buffer_size: usize,\\n    pub render_frequency: u32,\\n    pub memory_limit_mb: u64,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct ErrorRecoveryStrategy {\\n    pub restore_console_mode: bool,\\n    pub flush_input_buffer: bool,\\n    pub reset_cursor_visibility: bool,\\n    pub clear_screen_on_exit: bool,\\n}\\n\\nimpl Default for ErrorRecoveryStrategy {\\n    fn default() -> Self {\\n        Self {\\n            restore_console_mode: true,\\n            flush_input_buffer: true,\\n            reset_cursor_visibility: true,\\n            clear_screen_on_exit: true,\\n        }\\n    }\\n}\\n\\n/// Global platform manager instance\\nstatic PLATFORM_MANAGER: Lazy<Arc<PlatformManager>> = Lazy::new(|| {\\n    Arc::new(PlatformManager::new().expect(\\\"Failed to initialize platform manager\\\"))\\n});\\n\\n/// Get the global platform manager instance\\npub fn get_platform_manager() -> Arc<PlatformManager> {\\n    Arc::clone(&PLATFORM_MANAGER)\\n}\\n\\nimpl Default for PlatformManager {\\n    fn default() -> Self {\\n        Self::new().expect(\\\"Failed to create default platform manager\\\")\\n    }\\n}","highlight_start":6118,"highlight_end":6126}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try marking as source code","code":null,"level":"help","spans":[{"file_name":"platform/src/lib.rs","byte_start":6114,"byte_end":6114,"line_start":1,"line_end":1,"column_start":6115,"column_end":6115,"is_primary":true,"text":[{"text":"//! # Centotype Platform\\n//!\\n//! Platform-specific integrations and optimizations for different operating systems\\n//! and terminal environments. This crate provides:\\n//!\\n//! - Terminal capability detection and optimization\\n//! - OS-specific performance optimizations\\n//! - Cross-platform terminal handling abstractions\\n//! - Hardware detection and feature availability\\n//!\\n//! ## Supported Platforms\\n//!\\n//! - **Linux**: Full support with optimizations for common terminals\\n//! - **macOS**: Native terminal integration with performance tuning\\n//! - **Windows**: Windows Terminal, PowerShell, and cmd.exe support\\n//!\\n//! ## Performance Optimizations\\n//!\\n//! - Terminal-specific render optimizations\\n//! - Platform-native input handling\\n//! - Memory management tuning per OS\\n//! - CPU architecture detection\\n\\npub mod terminal;\\npub mod input;\\npub mod performance;\\npub mod detection;\\n\\n// Re-export main types\\npub use terminal::{TerminalCapabilities, TerminalType, TerminalManager};\\npub use input::{PlatformInput, InputOptimizations};\\npub use performance::{PlatformPerformance, SystemMetrics};\\npub use detection::{PlatformDetector, PlatformInfo, OSType, Architecture};\\n\\nuse centotype_core::types::*;\\nuse std::sync::Arc;\\nuse once_cell::sync::Lazy;\\n\\n/// Main platform manager that coordinates all platform-specific functionality\\npub struct PlatformManager {\\n    info: PlatformInfo,\\n    terminal_caps: TerminalCapabilities,\\n    input_optimizations: InputOptimizations,\\n    performance_settings: PlatformPerformance,\\n}\\n\\nimpl PlatformManager {\\n    pub fn new() -> Result<Self> {\\n        let detector = PlatformDetector::new();\\n        let info = detector.detect_platform()?;\\n        let terminal_caps = detector.detect_terminal_capabilities()?;\\n        let input_optimizations = InputOptimizations::for_platform(&info)?;\\n        let performance_settings = PlatformPerformance::optimize_for_platform(&info)?;\\n\\n        tracing::info!(\\n            \\\"Platform detected: OS={:?}, Terminal={:?}, Arch={:?}\\\",\\n            info.os_type,\\n            terminal_caps.terminal_type,\\n            info.architecture\\n        );\\n\\n        Ok(Self {\\n            info,\\n            terminal_caps,\\n            input_optimizations,\\n            performance_settings,\\n        })\\n    }\\n\\n    pub fn platform_info(&self) -> &PlatformInfo {\\n        &self.info\\n    }\\n\\n    pub fn terminal_capabilities(&self) -> &TerminalCapabilities {\\n        &self.terminal_caps\\n    }\\n\\n    pub fn input_optimizations(&self) -> &InputOptimizations {\\n        &self.input_optimizations\\n    }\\n\\n    pub fn performance_settings(&self) -> &PlatformPerformance {\\n        &self.performance_settings\\n    }\\n\\n    /// Check if the platform meets minimum requirements\\n    pub fn validate_platform(&self) -> PlatformValidation {\\n        let mut issues = Vec::new();\\n        let mut warnings = Vec::new();\\n\\n        // Check terminal capabilities\\n        if !self.terminal_caps.supports_raw_mode {\\n            issues.push(\\\"Terminal does not support raw mode\\\".to_string());\\n        }\\n\\n        if !self.terminal_caps.supports_color {\\n            warnings.push(\\\"Terminal does not support color - using monochrome mode\\\".to_string());\\n        }\\n\\n        // Check performance capabilities\\n        if !self.performance_settings.can_meet_targets {\\n            warnings.push(\\\"Platform may not meet performance targets\\\".to_string());\\n        }\\n\\n        // Check input handling\\n        if !self.input_optimizations.high_precision_timing {\\n            warnings.push(\\\"High precision input timing not available\\\".to_string());\\n        }\\n\\n        PlatformValidation {\\n            is_supported: issues.is_empty(),\\n            issues,\\n            warnings,\\n            recommended_settings: self.get_recommended_settings(),\\n        }\\n    }\\n\\n    fn get_recommended_settings(&self) -> RecommendedSettings {\\n        RecommendedSettings {\\n            use_reduced_effects: !self.performance_settings.can_meet_targets,\\n            buffer_size: self.input_optimizations.recommended_buffer_size,\\n            render_frequency: self.performance_settings.recommended_fps,\\n            memory_limit_mb: self.performance_settings.memory_limit_mb,\\n        }\\n    }\\n\\n    /// Apply platform-specific optimizations\\n    pub fn apply_optimizations(&self) -> Result<()> {\\n        // Apply input optimizations\\n        self.input_optimizations.configure_input_system()?;\\n        \\n        // Apply performance optimizations  \\n        self.performance_settings.configure_performance()?;\\n        \\n        // Configure terminal-specific settings\\n        self.terminal_caps.configure_terminal()?;\\n        \\n        tracing::info!(\\\"Platform optimizations applied successfully\\\");\\n        Ok(())\\n    }\\n\\n    /// Get system resource information\\n    pub fn get_system_metrics(&self) -> SystemMetrics {\\n        self.performance_settings.get_current_metrics()\\n    }\\n\\n    /// Check if graceful degradation is needed\\n    pub fn should_use_fallback_mode(&self) -> bool {\\n        !self.performance_settings.can_meet_targets\\n            || self.terminal_caps.has_limitations()\\n    }\\n\\n    /// Get platform-specific error recovery strategies\\n    pub fn get_error_recovery(&self) -> ErrorRecoveryStrategy {\\n        match self.info.os_type {\\n            OSType::Windows => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: true,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: false,\\n            },\\n            OSType::MacOS | OSType::Linux => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: false,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: true,\\n            },\\n            OSType::Unknown => ErrorRecoveryStrategy::default(),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct PlatformValidation {\\n    pub is_supported: bool,\\n    pub issues: Vec<String>,\\n    pub warnings: Vec<String>,\\n    pub recommended_settings: RecommendedSettings,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct RecommendedSettings {\\n    pub use_reduced_effects: bool,\\n    pub buffer_size: usize,\\n    pub render_frequency: u32,\\n    pub memory_limit_mb: u64,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct ErrorRecoveryStrategy {\\n    pub restore_console_mode: bool,\\n    pub flush_input_buffer: bool,\\n    pub reset_cursor_visibility: bool,\\n    pub clear_screen_on_exit: bool,\\n}\\n\\nimpl Default for ErrorRecoveryStrategy {\\n    fn default() -> Self {\\n        Self {\\n            restore_console_mode: true,\\n            flush_input_buffer: true,\\n            reset_cursor_visibility: true,\\n            clear_screen_on_exit: true,\\n        }\\n    }\\n}\\n\\n/// Global platform manager instance\\nstatic PLATFORM_MANAGER: Lazy<Arc<PlatformManager>> = Lazy::new(|| {\\n    Arc::new(PlatformManager::new().expect(\\\"Failed to initialize platform manager\\\"))\\n});\\n\\n/// Get the global platform manager instance\\npub fn get_platform_manager() -> Arc<PlatformManager> {\\n    Arc::clone(&PLATFORM_MANAGER)\\n}\\n\\nimpl Default for PlatformManager {\\n    fn default() -> Self {\\n        Self::new().expect(\\\"Failed to create default platform manager\\\")\\n    }\\n}","highlight_start":6115,"highlight_end":6115}],"label":null,"suggested_replacement":"`","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"platform/src/lib.rs","byte_start":6125,"byte_end":6125,"line_start":1,"line_end":1,"column_start":6126,"column_end":6126,"is_primary":true,"text":[{"text":"//! # Centotype Platform\\n//!\\n//! Platform-specific integrations and optimizations for different operating systems\\n//! and terminal environments. This crate provides:\\n//!\\n//! - Terminal capability detection and optimization\\n//! - OS-specific performance optimizations\\n//! - Cross-platform terminal handling abstractions\\n//! - Hardware detection and feature availability\\n//!\\n//! ## Supported Platforms\\n//!\\n//! - **Linux**: Full support with optimizations for common terminals\\n//! - **macOS**: Native terminal integration with performance tuning\\n//! - **Windows**: Windows Terminal, PowerShell, and cmd.exe support\\n//!\\n//! ## Performance Optimizations\\n//!\\n//! - Terminal-specific render optimizations\\n//! - Platform-native input handling\\n//! - Memory management tuning per OS\\n//! - CPU architecture detection\\n\\npub mod terminal;\\npub mod input;\\npub mod performance;\\npub mod detection;\\n\\n// Re-export main types\\npub use terminal::{TerminalCapabilities, TerminalType, TerminalManager};\\npub use input::{PlatformInput, InputOptimizations};\\npub use performance::{PlatformPerformance, SystemMetrics};\\npub use detection::{PlatformDetector, PlatformInfo, OSType, Architecture};\\n\\nuse centotype_core::types::*;\\nuse std::sync::Arc;\\nuse once_cell::sync::Lazy;\\n\\n/// Main platform manager that coordinates all platform-specific functionality\\npub struct PlatformManager {\\n    info: PlatformInfo,\\n    terminal_caps: TerminalCapabilities,\\n    input_optimizations: InputOptimizations,\\n    performance_settings: PlatformPerformance,\\n}\\n\\nimpl PlatformManager {\\n    pub fn new() -> Result<Self> {\\n        let detector = PlatformDetector::new();\\n        let info = detector.detect_platform()?;\\n        let terminal_caps = detector.detect_terminal_capabilities()?;\\n        let input_optimizations = InputOptimizations::for_platform(&info)?;\\n        let performance_settings = PlatformPerformance::optimize_for_platform(&info)?;\\n\\n        tracing::info!(\\n            \\\"Platform detected: OS={:?}, Terminal={:?}, Arch={:?}\\\",\\n            info.os_type,\\n            terminal_caps.terminal_type,\\n            info.architecture\\n        );\\n\\n        Ok(Self {\\n            info,\\n            terminal_caps,\\n            input_optimizations,\\n            performance_settings,\\n        })\\n    }\\n\\n    pub fn platform_info(&self) -> &PlatformInfo {\\n        &self.info\\n    }\\n\\n    pub fn terminal_capabilities(&self) -> &TerminalCapabilities {\\n        &self.terminal_caps\\n    }\\n\\n    pub fn input_optimizations(&self) -> &InputOptimizations {\\n        &self.input_optimizations\\n    }\\n\\n    pub fn performance_settings(&self) -> &PlatformPerformance {\\n        &self.performance_settings\\n    }\\n\\n    /// Check if the platform meets minimum requirements\\n    pub fn validate_platform(&self) -> PlatformValidation {\\n        let mut issues = Vec::new();\\n        let mut warnings = Vec::new();\\n\\n        // Check terminal capabilities\\n        if !self.terminal_caps.supports_raw_mode {\\n            issues.push(\\\"Terminal does not support raw mode\\\".to_string());\\n        }\\n\\n        if !self.terminal_caps.supports_color {\\n            warnings.push(\\\"Terminal does not support color - using monochrome mode\\\".to_string());\\n        }\\n\\n        // Check performance capabilities\\n        if !self.performance_settings.can_meet_targets {\\n            warnings.push(\\\"Platform may not meet performance targets\\\".to_string());\\n        }\\n\\n        // Check input handling\\n        if !self.input_optimizations.high_precision_timing {\\n            warnings.push(\\\"High precision input timing not available\\\".to_string());\\n        }\\n\\n        PlatformValidation {\\n            is_supported: issues.is_empty(),\\n            issues,\\n            warnings,\\n            recommended_settings: self.get_recommended_settings(),\\n        }\\n    }\\n\\n    fn get_recommended_settings(&self) -> RecommendedSettings {\\n        RecommendedSettings {\\n            use_reduced_effects: !self.performance_settings.can_meet_targets,\\n            buffer_size: self.input_optimizations.recommended_buffer_size,\\n            render_frequency: self.performance_settings.recommended_fps,\\n            memory_limit_mb: self.performance_settings.memory_limit_mb,\\n        }\\n    }\\n\\n    /// Apply platform-specific optimizations\\n    pub fn apply_optimizations(&self) -> Result<()> {\\n        // Apply input optimizations\\n        self.input_optimizations.configure_input_system()?;\\n        \\n        // Apply performance optimizations  \\n        self.performance_settings.configure_performance()?;\\n        \\n        // Configure terminal-specific settings\\n        self.terminal_caps.configure_terminal()?;\\n        \\n        tracing::info!(\\\"Platform optimizations applied successfully\\\");\\n        Ok(())\\n    }\\n\\n    /// Get system resource information\\n    pub fn get_system_metrics(&self) -> SystemMetrics {\\n        self.performance_settings.get_current_metrics()\\n    }\\n\\n    /// Check if graceful degradation is needed\\n    pub fn should_use_fallback_mode(&self) -> bool {\\n        !self.performance_settings.can_meet_targets\\n            || self.terminal_caps.has_limitations()\\n    }\\n\\n    /// Get platform-specific error recovery strategies\\n    pub fn get_error_recovery(&self) -> ErrorRecoveryStrategy {\\n        match self.info.os_type {\\n            OSType::Windows => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: true,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: false,\\n            },\\n            OSType::MacOS | OSType::Linux => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: false,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: true,\\n            },\\n            OSType::Unknown => ErrorRecoveryStrategy::default(),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct PlatformValidation {\\n    pub is_supported: bool,\\n    pub issues: Vec<String>,\\n    pub warnings: Vec<String>,\\n    pub recommended_settings: RecommendedSettings,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct RecommendedSettings {\\n    pub use_reduced_effects: bool,\\n    pub buffer_size: usize,\\n    pub render_frequency: u32,\\n    pub memory_limit_mb: u64,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct ErrorRecoveryStrategy {\\n    pub restore_console_mode: bool,\\n    pub flush_input_buffer: bool,\\n    pub reset_cursor_visibility: bool,\\n    pub clear_screen_on_exit: bool,\\n}\\n\\nimpl Default for ErrorRecoveryStrategy {\\n    fn default() -> Self {\\n        Self {\\n            restore_console_mode: true,\\n            flush_input_buffer: true,\\n            reset_cursor_visibility: true,\\n            clear_screen_on_exit: true,\\n        }\\n    }\\n}\\n\\n/// Global platform manager instance\\nstatic PLATFORM_MANAGER: Lazy<Arc<PlatformManager>> = Lazy::new(|| {\\n    Arc::new(PlatformManager::new().expect(\\\"Failed to initialize platform manager\\\"))\\n});\\n\\n/// Get the global platform manager instance\\npub fn get_platform_manager() -> Arc<PlatformManager> {\\n    Arc::clone(&PLATFORM_MANAGER)\\n}\\n\\nimpl Default for PlatformManager {\\n    fn default() -> Self {\\n        Self::new().expect(\\\"Failed to create default platform manager\\\")\\n    }\\n}","highlight_start":6126,"highlight_end":6126}],"label":null,"suggested_replacement":"`","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unclosed HTML tag `String`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mplatform/src/lib.rs:1:6118\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0mted: bool,\\n    pub issues: Vec<String>,\\n    pub warnings: Vec<String>,\\n    pub recommended_settings: RecommendedSettings,\\n}\\n\\n#[d\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                   \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try marking as source code\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m//! # Centotype Platform\\n//!\\n//! Platform-specific integrations and optimizations for different operating systems\\n//! and terminal environments. This crate provides:\\n//!\\n//! - Terminal capability detection and optimization\\n//! - OS-specific performance optimizations\\n//! - Cross-platform terminal handling abstractions\\n//! - Hardware detection and feature availability\\n//!\\n//! ## Supported Platforms\\n//!\\n//! - **Linux**: Full support with optimizations for common terminals\\n//! - **macOS**: Native terminal integration with performance tuning\\n//! - **Windows**: Windows Terminal, PowerShell, and cmd.exe support\\n//!\\n//! ## Performance Optimizations\\n//!\\n//! - Terminal-specific render optimizations\\n//! - Platform-native input handling\\n//! - Memory management tuning per OS\\n//! - CPU architecture detection\\n\\npub mod terminal;\\npub mod input;\\npub mod performance;\\npub mod detection;\\n\\n// Re-export main types\\npub use terminal::{TerminalCapabilities, TerminalType, TerminalManager};\\npub use input::{PlatformInput, InputOptimizations};\\npub use performance::{PlatformPerformance, SystemMetrics};\\npub use detection::{PlatformDetector, PlatformInfo, OSType, Architecture};\\n\\nuse centotype_core::types::*;\\nuse std::sync::Arc;\\nuse once_cell::sync::Lazy;\\n\\n/// Main platform manager that coordinates all platform-specific functionality\\npub struct PlatformManager {\\n    info: PlatformInfo,\\n    terminal_caps: TerminalCapabilities,\\n    input_optimizations: InputOptimizations,\\n    performance_settings: PlatformPerformance,\\n}\\n\\nimpl PlatformManager {\\n    pub fn new() -> Result<Self> {\\n        let detector = PlatformDetector::new();\\n        let info = detector.detect_platform()?;\\n        let terminal_caps = detector.detect_terminal_capabilities()?;\\n        let input_optimizations = InputOptimizations::for_platform(&info)?;\\n        let performance_settings = PlatformPerformance::optimize_for_platform(&info)?;\\n\\n        tracing::info!(\\n            \\\"Platform detected: OS={:?}, Terminal={:?}, Arch={:?}\\\",\\n            info.os_type,\\n            terminal_caps.terminal_type,\\n            info.architecture\\n        );\\n\\n        Ok(Self {\\n            info,\\n            terminal_caps,\\n            input_optimizations,\\n            performance_settings,\\n        })\\n    }\\n\\n    pub fn platform_info(&self) -> &PlatformInfo {\\n        &self.info\\n    }\\n\\n    pub fn terminal_capabilities(&self) -> &TerminalCapabilities {\\n        &self.terminal_caps\\n    }\\n\\n    pub fn input_optimizations(&self) -> &InputOptimizations {\\n        &self.input_optimizations\\n    }\\n\\n    pub fn performance_settings(&self) -> &PlatformPerformance {\\n        &self.performance_settings\\n    }\\n\\n    /// Check if the platform meets minimum requirements\\n    pub fn validate_platform(&self) -> PlatformValidation {\\n        let mut issues = Vec::new();\\n        let mut warnings = Vec::new();\\n\\n        // Check terminal capabilities\\n        if !self.terminal_caps.supports_raw_mode {\\n            issues.push(\\\"Terminal does not support raw mode\\\".to_string());\\n        }\\n\\n        if !self.terminal_caps.supports_color {\\n            warnings.push(\\\"Terminal does not support color - using monochrome mode\\\".to_string());\\n        }\\n\\n        // Check performance capabilities\\n        if !self.performance_settings.can_meet_targets {\\n            warnings.push(\\\"Platform may not meet performance targets\\\".to_string());\\n        }\\n\\n        // Check input handling\\n        if !self.input_optimizations.high_precision_timing {\\n            warnings.push(\\\"High precision input timing not available\\\".to_string());\\n        }\\n\\n        PlatformValidation {\\n            is_supported: issues.is_empty(),\\n            issues,\\n            warnings,\\n            recommended_settings: self.get_recommended_settings(),\\n        }\\n    }\\n\\n    fn get_recommended_settings(&self) -> RecommendedSettings {\\n        RecommendedSettings {\\n            use_reduced_effects: !self.performance_settings.can_meet_targets,\\n            buffer_size: self.input_optimizations.recommended_buffer_size,\\n            render_frequency: self.performance_settings.recommended_fps,\\n            memory_limit_mb: self.performance_settings.memory_limit_mb,\\n        }\\n    }\\n\\n    /// Apply platform-specific optimizations\\n    pub fn apply_optimizations(&self) -> Result<()> {\\n        // Apply input optimizations\\n        self.input_optimizations.configure_input_system()?;\\n        \\n        // Apply performance optimizations  \\n        self.performance_settings.configure_performance()?;\\n        \\n        // Configure terminal-specific settings\\n        self.terminal_caps.configure_terminal()?;\\n        \\n        tracing::info!(\\\"Platform optimizations applied successfully\\\");\\n        Ok(())\\n    }\\n\\n    /// Get system resource information\\n    pub fn get_system_metrics(&self) -> SystemMetrics {\\n        self.performance_settings.get_current_metrics()\\n    }\\n\\n    /// Check if graceful degradation is needed\\n    pub fn should_use_fallback_mode(&self) -> bool {\\n        !self.performance_settings.can_meet_targets\\n            || self.terminal_caps.has_limitations()\\n    }\\n\\n    /// Get platform-specific error recovery strategies\\n    pub fn get_error_recovery(&self) -> ErrorRecoveryStrategy {\\n        match self.info.os_type {\\n            OSType::Windows => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: true,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: false,\\n            },\\n            OSType::MacOS | OSType::Linux => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: false,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: true,\\n            },\\n            OSType::Unknown => ErrorRecoveryStrategy::default(),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct PlatformValidation {\\n    pub is_supported: bool,\\n    pub issues: Vec<String>,\\n    pub warnings: \u001b[0m\u001b[0m\u001b[38;5;10m`\u001b[0m\u001b[0mVec<String>\u001b[0m\u001b[0m\u001b[38;5;10m`\u001b[0m\u001b[0m,\\n    pub recommended_settings: RecommendedSettings,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct RecommendedSettings {\\n    pub use_reduced_effects: bool,\\n    pub buffer_size: usize,\\n    pub render_frequency: u32,\\n    pub memory_limit_mb: u64,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct ErrorRecoveryStrategy {\\n    pub restore_console_mode: bool,\\n    pub flush_input_buffer: bool,\\n    pub reset_cursor_visibility: bool,\\n    pub clear_screen_on_exit: bool,\\n}\\n\\nimpl Default for ErrorRecoveryStrategy {\\n    fn default() -> Self {\\n        Self {\\n            restore_console_mode: true,\\n            flush_input_buffer: true,\\n            reset_cursor_visibility: true,\\n            clear_screen_on_exit: true,\\n        }\\n    }\\n}\\n\\n/// Global platform manager instance\\nstatic PLATFORM_MANAGER: Lazy<Arc<PlatformManager>> = Lazy::new(|| {\\n    Arc::new(PlatformManager::new().expect(\\\"Failed to initialize platform manager\\\"))\\n});\\n\\n/// Get the global platform manager instance\\npub fn get_platform_manager() -> Arc<PlatformManager> {\\n    Arc::clone(&PLATFORM_MANAGER)\\n}\\n\\nimpl Default for PlatformManager {\\n    fn default() -> Self {\\n        Self::new().expect(\\\"Failed to create default platform manager\\\")\\n    }\\n}\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\u001b[0m           \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unclosed HTML tag `PlatformManager`","code":{"code":"rustdoc::invalid_html_tags","explanation":null},"level":"warning","spans":[{"file_name":"platform/src/lib.rs","byte_start":6937,"byte_end":6954,"line_start":1,"line_end":1,"column_start":6938,"column_end":6955,"is_primary":true,"text":[{"text":"//! # Centotype Platform\\n//!\\n//! Platform-specific integrations and optimizations for different operating systems\\n//! and terminal environments. This crate provides:\\n//!\\n//! - Terminal capability detection and optimization\\n//! - OS-specific performance optimizations\\n//! - Cross-platform terminal handling abstractions\\n//! - Hardware detection and feature availability\\n//!\\n//! ## Supported Platforms\\n//!\\n//! - **Linux**: Full support with optimizations for common terminals\\n//! - **macOS**: Native terminal integration with performance tuning\\n//! - **Windows**: Windows Terminal, PowerShell, and cmd.exe support\\n//!\\n//! ## Performance Optimizations\\n//!\\n//! - Terminal-specific render optimizations\\n//! - Platform-native input handling\\n//! - Memory management tuning per OS\\n//! - CPU architecture detection\\n\\npub mod terminal;\\npub mod input;\\npub mod performance;\\npub mod detection;\\n\\n// Re-export main types\\npub use terminal::{TerminalCapabilities, TerminalType, TerminalManager};\\npub use input::{PlatformInput, InputOptimizations};\\npub use performance::{PlatformPerformance, SystemMetrics};\\npub use detection::{PlatformDetector, PlatformInfo, OSType, Architecture};\\n\\nuse centotype_core::types::*;\\nuse std::sync::Arc;\\nuse once_cell::sync::Lazy;\\n\\n/// Main platform manager that coordinates all platform-specific functionality\\npub struct PlatformManager {\\n    info: PlatformInfo,\\n    terminal_caps: TerminalCapabilities,\\n    input_optimizations: InputOptimizations,\\n    performance_settings: PlatformPerformance,\\n}\\n\\nimpl PlatformManager {\\n    pub fn new() -> Result<Self> {\\n        let detector = PlatformDetector::new();\\n        let info = detector.detect_platform()?;\\n        let terminal_caps = detector.detect_terminal_capabilities()?;\\n        let input_optimizations = InputOptimizations::for_platform(&info)?;\\n        let performance_settings = PlatformPerformance::optimize_for_platform(&info)?;\\n\\n        tracing::info!(\\n            \\\"Platform detected: OS={:?}, Terminal={:?}, Arch={:?}\\\",\\n            info.os_type,\\n            terminal_caps.terminal_type,\\n            info.architecture\\n        );\\n\\n        Ok(Self {\\n            info,\\n            terminal_caps,\\n            input_optimizations,\\n            performance_settings,\\n        })\\n    }\\n\\n    pub fn platform_info(&self) -> &PlatformInfo {\\n        &self.info\\n    }\\n\\n    pub fn terminal_capabilities(&self) -> &TerminalCapabilities {\\n        &self.terminal_caps\\n    }\\n\\n    pub fn input_optimizations(&self) -> &InputOptimizations {\\n        &self.input_optimizations\\n    }\\n\\n    pub fn performance_settings(&self) -> &PlatformPerformance {\\n        &self.performance_settings\\n    }\\n\\n    /// Check if the platform meets minimum requirements\\n    pub fn validate_platform(&self) -> PlatformValidation {\\n        let mut issues = Vec::new();\\n        let mut warnings = Vec::new();\\n\\n        // Check terminal capabilities\\n        if !self.terminal_caps.supports_raw_mode {\\n            issues.push(\\\"Terminal does not support raw mode\\\".to_string());\\n        }\\n\\n        if !self.terminal_caps.supports_color {\\n            warnings.push(\\\"Terminal does not support color - using monochrome mode\\\".to_string());\\n        }\\n\\n        // Check performance capabilities\\n        if !self.performance_settings.can_meet_targets {\\n            warnings.push(\\\"Platform may not meet performance targets\\\".to_string());\\n        }\\n\\n        // Check input handling\\n        if !self.input_optimizations.high_precision_timing {\\n            warnings.push(\\\"High precision input timing not available\\\".to_string());\\n        }\\n\\n        PlatformValidation {\\n            is_supported: issues.is_empty(),\\n            issues,\\n            warnings,\\n            recommended_settings: self.get_recommended_settings(),\\n        }\\n    }\\n\\n    fn get_recommended_settings(&self) -> RecommendedSettings {\\n        RecommendedSettings {\\n            use_reduced_effects: !self.performance_settings.can_meet_targets,\\n            buffer_size: self.input_optimizations.recommended_buffer_size,\\n            render_frequency: self.performance_settings.recommended_fps,\\n            memory_limit_mb: self.performance_settings.memory_limit_mb,\\n        }\\n    }\\n\\n    /// Apply platform-specific optimizations\\n    pub fn apply_optimizations(&self) -> Result<()> {\\n        // Apply input optimizations\\n        self.input_optimizations.configure_input_system()?;\\n        \\n        // Apply performance optimizations  \\n        self.performance_settings.configure_performance()?;\\n        \\n        // Configure terminal-specific settings\\n        self.terminal_caps.configure_terminal()?;\\n        \\n        tracing::info!(\\\"Platform optimizations applied successfully\\\");\\n        Ok(())\\n    }\\n\\n    /// Get system resource information\\n    pub fn get_system_metrics(&self) -> SystemMetrics {\\n        self.performance_settings.get_current_metrics()\\n    }\\n\\n    /// Check if graceful degradation is needed\\n    pub fn should_use_fallback_mode(&self) -> bool {\\n        !self.performance_settings.can_meet_targets\\n            || self.terminal_caps.has_limitations()\\n    }\\n\\n    /// Get platform-specific error recovery strategies\\n    pub fn get_error_recovery(&self) -> ErrorRecoveryStrategy {\\n        match self.info.os_type {\\n            OSType::Windows => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: true,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: false,\\n            },\\n            OSType::MacOS | OSType::Linux => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: false,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: true,\\n            },\\n            OSType::Unknown => ErrorRecoveryStrategy::default(),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct PlatformValidation {\\n    pub is_supported: bool,\\n    pub issues: Vec<String>,\\n    pub warnings: Vec<String>,\\n    pub recommended_settings: RecommendedSettings,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct RecommendedSettings {\\n    pub use_reduced_effects: bool,\\n    pub buffer_size: usize,\\n    pub render_frequency: u32,\\n    pub memory_limit_mb: u64,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct ErrorRecoveryStrategy {\\n    pub restore_console_mode: bool,\\n    pub flush_input_buffer: bool,\\n    pub reset_cursor_visibility: bool,\\n    pub clear_screen_on_exit: bool,\\n}\\n\\nimpl Default for ErrorRecoveryStrategy {\\n    fn default() -> Self {\\n        Self {\\n            restore_console_mode: true,\\n            flush_input_buffer: true,\\n            reset_cursor_visibility: true,\\n            clear_screen_on_exit: true,\\n        }\\n    }\\n}\\n\\n/// Global platform manager instance\\nstatic PLATFORM_MANAGER: Lazy<Arc<PlatformManager>> = Lazy::new(|| {\\n    Arc::new(PlatformManager::new().expect(\\\"Failed to initialize platform manager\\\"))\\n});\\n\\n/// Get the global platform manager instance\\npub fn get_platform_manager() -> Arc<PlatformManager> {\\n    Arc::clone(&PLATFORM_MANAGER)\\n}\\n\\nimpl Default for PlatformManager {\\n    fn default() -> Self {\\n        Self::new().expect(\\\"Failed to create default platform manager\\\")\\n    }\\n}","highlight_start":6938,"highlight_end":6955}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try marking as source code","code":null,"level":"help","spans":[{"file_name":"platform/src/lib.rs","byte_start":6929,"byte_end":6929,"line_start":1,"line_end":1,"column_start":6930,"column_end":6930,"is_primary":true,"text":[{"text":"//! # Centotype Platform\\n//!\\n//! Platform-specific integrations and optimizations for different operating systems\\n//! and terminal environments. This crate provides:\\n//!\\n//! - Terminal capability detection and optimization\\n//! - OS-specific performance optimizations\\n//! - Cross-platform terminal handling abstractions\\n//! - Hardware detection and feature availability\\n//!\\n//! ## Supported Platforms\\n//!\\n//! - **Linux**: Full support with optimizations for common terminals\\n//! - **macOS**: Native terminal integration with performance tuning\\n//! - **Windows**: Windows Terminal, PowerShell, and cmd.exe support\\n//!\\n//! ## Performance Optimizations\\n//!\\n//! - Terminal-specific render optimizations\\n//! - Platform-native input handling\\n//! - Memory management tuning per OS\\n//! - CPU architecture detection\\n\\npub mod terminal;\\npub mod input;\\npub mod performance;\\npub mod detection;\\n\\n// Re-export main types\\npub use terminal::{TerminalCapabilities, TerminalType, TerminalManager};\\npub use input::{PlatformInput, InputOptimizations};\\npub use performance::{PlatformPerformance, SystemMetrics};\\npub use detection::{PlatformDetector, PlatformInfo, OSType, Architecture};\\n\\nuse centotype_core::types::*;\\nuse std::sync::Arc;\\nuse once_cell::sync::Lazy;\\n\\n/// Main platform manager that coordinates all platform-specific functionality\\npub struct PlatformManager {\\n    info: PlatformInfo,\\n    terminal_caps: TerminalCapabilities,\\n    input_optimizations: InputOptimizations,\\n    performance_settings: PlatformPerformance,\\n}\\n\\nimpl PlatformManager {\\n    pub fn new() -> Result<Self> {\\n        let detector = PlatformDetector::new();\\n        let info = detector.detect_platform()?;\\n        let terminal_caps = detector.detect_terminal_capabilities()?;\\n        let input_optimizations = InputOptimizations::for_platform(&info)?;\\n        let performance_settings = PlatformPerformance::optimize_for_platform(&info)?;\\n\\n        tracing::info!(\\n            \\\"Platform detected: OS={:?}, Terminal={:?}, Arch={:?}\\\",\\n            info.os_type,\\n            terminal_caps.terminal_type,\\n            info.architecture\\n        );\\n\\n        Ok(Self {\\n            info,\\n            terminal_caps,\\n            input_optimizations,\\n            performance_settings,\\n        })\\n    }\\n\\n    pub fn platform_info(&self) -> &PlatformInfo {\\n        &self.info\\n    }\\n\\n    pub fn terminal_capabilities(&self) -> &TerminalCapabilities {\\n        &self.terminal_caps\\n    }\\n\\n    pub fn input_optimizations(&self) -> &InputOptimizations {\\n        &self.input_optimizations\\n    }\\n\\n    pub fn performance_settings(&self) -> &PlatformPerformance {\\n        &self.performance_settings\\n    }\\n\\n    /// Check if the platform meets minimum requirements\\n    pub fn validate_platform(&self) -> PlatformValidation {\\n        let mut issues = Vec::new();\\n        let mut warnings = Vec::new();\\n\\n        // Check terminal capabilities\\n        if !self.terminal_caps.supports_raw_mode {\\n            issues.push(\\\"Terminal does not support raw mode\\\".to_string());\\n        }\\n\\n        if !self.terminal_caps.supports_color {\\n            warnings.push(\\\"Terminal does not support color - using monochrome mode\\\".to_string());\\n        }\\n\\n        // Check performance capabilities\\n        if !self.performance_settings.can_meet_targets {\\n            warnings.push(\\\"Platform may not meet performance targets\\\".to_string());\\n        }\\n\\n        // Check input handling\\n        if !self.input_optimizations.high_precision_timing {\\n            warnings.push(\\\"High precision input timing not available\\\".to_string());\\n        }\\n\\n        PlatformValidation {\\n            is_supported: issues.is_empty(),\\n            issues,\\n            warnings,\\n            recommended_settings: self.get_recommended_settings(),\\n        }\\n    }\\n\\n    fn get_recommended_settings(&self) -> RecommendedSettings {\\n        RecommendedSettings {\\n            use_reduced_effects: !self.performance_settings.can_meet_targets,\\n            buffer_size: self.input_optimizations.recommended_buffer_size,\\n            render_frequency: self.performance_settings.recommended_fps,\\n            memory_limit_mb: self.performance_settings.memory_limit_mb,\\n        }\\n    }\\n\\n    /// Apply platform-specific optimizations\\n    pub fn apply_optimizations(&self) -> Result<()> {\\n        // Apply input optimizations\\n        self.input_optimizations.configure_input_system()?;\\n        \\n        // Apply performance optimizations  \\n        self.performance_settings.configure_performance()?;\\n        \\n        // Configure terminal-specific settings\\n        self.terminal_caps.configure_terminal()?;\\n        \\n        tracing::info!(\\\"Platform optimizations applied successfully\\\");\\n        Ok(())\\n    }\\n\\n    /// Get system resource information\\n    pub fn get_system_metrics(&self) -> SystemMetrics {\\n        self.performance_settings.get_current_metrics()\\n    }\\n\\n    /// Check if graceful degradation is needed\\n    pub fn should_use_fallback_mode(&self) -> bool {\\n        !self.performance_settings.can_meet_targets\\n            || self.terminal_caps.has_limitations()\\n    }\\n\\n    /// Get platform-specific error recovery strategies\\n    pub fn get_error_recovery(&self) -> ErrorRecoveryStrategy {\\n        match self.info.os_type {\\n            OSType::Windows => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: true,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: false,\\n            },\\n            OSType::MacOS | OSType::Linux => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: false,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: true,\\n            },\\n            OSType::Unknown => ErrorRecoveryStrategy::default(),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct PlatformValidation {\\n    pub is_supported: bool,\\n    pub issues: Vec<String>,\\n    pub warnings: Vec<String>,\\n    pub recommended_settings: RecommendedSettings,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct RecommendedSettings {\\n    pub use_reduced_effects: bool,\\n    pub buffer_size: usize,\\n    pub render_frequency: u32,\\n    pub memory_limit_mb: u64,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct ErrorRecoveryStrategy {\\n    pub restore_console_mode: bool,\\n    pub flush_input_buffer: bool,\\n    pub reset_cursor_visibility: bool,\\n    pub clear_screen_on_exit: bool,\\n}\\n\\nimpl Default for ErrorRecoveryStrategy {\\n    fn default() -> Self {\\n        Self {\\n            restore_console_mode: true,\\n            flush_input_buffer: true,\\n            reset_cursor_visibility: true,\\n            clear_screen_on_exit: true,\\n        }\\n    }\\n}\\n\\n/// Global platform manager instance\\nstatic PLATFORM_MANAGER: Lazy<Arc<PlatformManager>> = Lazy::new(|| {\\n    Arc::new(PlatformManager::new().expect(\\\"Failed to initialize platform manager\\\"))\\n});\\n\\n/// Get the global platform manager instance\\npub fn get_platform_manager() -> Arc<PlatformManager> {\\n    Arc::clone(&PLATFORM_MANAGER)\\n}\\n\\nimpl Default for PlatformManager {\\n    fn default() -> Self {\\n        Self::new().expect(\\\"Failed to create default platform manager\\\")\\n    }\\n}","highlight_start":6930,"highlight_end":6930}],"label":null,"suggested_replacement":"`","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"platform/src/lib.rs","byte_start":6955,"byte_end":6955,"line_start":1,"line_end":1,"column_start":6956,"column_end":6956,"is_primary":true,"text":[{"text":"//! # Centotype Platform\\n//!\\n//! Platform-specific integrations and optimizations for different operating systems\\n//! and terminal environments. This crate provides:\\n//!\\n//! - Terminal capability detection and optimization\\n//! - OS-specific performance optimizations\\n//! - Cross-platform terminal handling abstractions\\n//! - Hardware detection and feature availability\\n//!\\n//! ## Supported Platforms\\n//!\\n//! - **Linux**: Full support with optimizations for common terminals\\n//! - **macOS**: Native terminal integration with performance tuning\\n//! - **Windows**: Windows Terminal, PowerShell, and cmd.exe support\\n//!\\n//! ## Performance Optimizations\\n//!\\n//! - Terminal-specific render optimizations\\n//! - Platform-native input handling\\n//! - Memory management tuning per OS\\n//! - CPU architecture detection\\n\\npub mod terminal;\\npub mod input;\\npub mod performance;\\npub mod detection;\\n\\n// Re-export main types\\npub use terminal::{TerminalCapabilities, TerminalType, TerminalManager};\\npub use input::{PlatformInput, InputOptimizations};\\npub use performance::{PlatformPerformance, SystemMetrics};\\npub use detection::{PlatformDetector, PlatformInfo, OSType, Architecture};\\n\\nuse centotype_core::types::*;\\nuse std::sync::Arc;\\nuse once_cell::sync::Lazy;\\n\\n/// Main platform manager that coordinates all platform-specific functionality\\npub struct PlatformManager {\\n    info: PlatformInfo,\\n    terminal_caps: TerminalCapabilities,\\n    input_optimizations: InputOptimizations,\\n    performance_settings: PlatformPerformance,\\n}\\n\\nimpl PlatformManager {\\n    pub fn new() -> Result<Self> {\\n        let detector = PlatformDetector::new();\\n        let info = detector.detect_platform()?;\\n        let terminal_caps = detector.detect_terminal_capabilities()?;\\n        let input_optimizations = InputOptimizations::for_platform(&info)?;\\n        let performance_settings = PlatformPerformance::optimize_for_platform(&info)?;\\n\\n        tracing::info!(\\n            \\\"Platform detected: OS={:?}, Terminal={:?}, Arch={:?}\\\",\\n            info.os_type,\\n            terminal_caps.terminal_type,\\n            info.architecture\\n        );\\n\\n        Ok(Self {\\n            info,\\n            terminal_caps,\\n            input_optimizations,\\n            performance_settings,\\n        })\\n    }\\n\\n    pub fn platform_info(&self) -> &PlatformInfo {\\n        &self.info\\n    }\\n\\n    pub fn terminal_capabilities(&self) -> &TerminalCapabilities {\\n        &self.terminal_caps\\n    }\\n\\n    pub fn input_optimizations(&self) -> &InputOptimizations {\\n        &self.input_optimizations\\n    }\\n\\n    pub fn performance_settings(&self) -> &PlatformPerformance {\\n        &self.performance_settings\\n    }\\n\\n    /// Check if the platform meets minimum requirements\\n    pub fn validate_platform(&self) -> PlatformValidation {\\n        let mut issues = Vec::new();\\n        let mut warnings = Vec::new();\\n\\n        // Check terminal capabilities\\n        if !self.terminal_caps.supports_raw_mode {\\n            issues.push(\\\"Terminal does not support raw mode\\\".to_string());\\n        }\\n\\n        if !self.terminal_caps.supports_color {\\n            warnings.push(\\\"Terminal does not support color - using monochrome mode\\\".to_string());\\n        }\\n\\n        // Check performance capabilities\\n        if !self.performance_settings.can_meet_targets {\\n            warnings.push(\\\"Platform may not meet performance targets\\\".to_string());\\n        }\\n\\n        // Check input handling\\n        if !self.input_optimizations.high_precision_timing {\\n            warnings.push(\\\"High precision input timing not available\\\".to_string());\\n        }\\n\\n        PlatformValidation {\\n            is_supported: issues.is_empty(),\\n            issues,\\n            warnings,\\n            recommended_settings: self.get_recommended_settings(),\\n        }\\n    }\\n\\n    fn get_recommended_settings(&self) -> RecommendedSettings {\\n        RecommendedSettings {\\n            use_reduced_effects: !self.performance_settings.can_meet_targets,\\n            buffer_size: self.input_optimizations.recommended_buffer_size,\\n            render_frequency: self.performance_settings.recommended_fps,\\n            memory_limit_mb: self.performance_settings.memory_limit_mb,\\n        }\\n    }\\n\\n    /// Apply platform-specific optimizations\\n    pub fn apply_optimizations(&self) -> Result<()> {\\n        // Apply input optimizations\\n        self.input_optimizations.configure_input_system()?;\\n        \\n        // Apply performance optimizations  \\n        self.performance_settings.configure_performance()?;\\n        \\n        // Configure terminal-specific settings\\n        self.terminal_caps.configure_terminal()?;\\n        \\n        tracing::info!(\\\"Platform optimizations applied successfully\\\");\\n        Ok(())\\n    }\\n\\n    /// Get system resource information\\n    pub fn get_system_metrics(&self) -> SystemMetrics {\\n        self.performance_settings.get_current_metrics()\\n    }\\n\\n    /// Check if graceful degradation is needed\\n    pub fn should_use_fallback_mode(&self) -> bool {\\n        !self.performance_settings.can_meet_targets\\n            || self.terminal_caps.has_limitations()\\n    }\\n\\n    /// Get platform-specific error recovery strategies\\n    pub fn get_error_recovery(&self) -> ErrorRecoveryStrategy {\\n        match self.info.os_type {\\n            OSType::Windows => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: true,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: false,\\n            },\\n            OSType::MacOS | OSType::Linux => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: false,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: true,\\n            },\\n            OSType::Unknown => ErrorRecoveryStrategy::default(),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct PlatformValidation {\\n    pub is_supported: bool,\\n    pub issues: Vec<String>,\\n    pub warnings: Vec<String>,\\n    pub recommended_settings: RecommendedSettings,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct RecommendedSettings {\\n    pub use_reduced_effects: bool,\\n    pub buffer_size: usize,\\n    pub render_frequency: u32,\\n    pub memory_limit_mb: u64,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct ErrorRecoveryStrategy {\\n    pub restore_console_mode: bool,\\n    pub flush_input_buffer: bool,\\n    pub reset_cursor_visibility: bool,\\n    pub clear_screen_on_exit: bool,\\n}\\n\\nimpl Default for ErrorRecoveryStrategy {\\n    fn default() -> Self {\\n        Self {\\n            restore_console_mode: true,\\n            flush_input_buffer: true,\\n            reset_cursor_visibility: true,\\n            clear_screen_on_exit: true,\\n        }\\n    }\\n}\\n\\n/// Global platform manager instance\\nstatic PLATFORM_MANAGER: Lazy<Arc<PlatformManager>> = Lazy::new(|| {\\n    Arc::new(PlatformManager::new().expect(\\\"Failed to initialize platform manager\\\"))\\n});\\n\\n/// Get the global platform manager instance\\npub fn get_platform_manager() -> Arc<PlatformManager> {\\n    Arc::clone(&PLATFORM_MANAGER)\\n}\\n\\nimpl Default for PlatformManager {\\n    fn default() -> Self {\\n        Self::new().expect(\\\"Failed to create default platform manager\\\")\\n    }\\n}","highlight_start":6956,"highlight_end":6956}],"label":null,"suggested_replacement":"`","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unclosed HTML tag `PlatformManager`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mplatform/src/lib.rs:1:6938\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0matform manager instance\\nstatic PLATFORM_MANAGER: Lazy<Arc<PlatformManager>> = Lazy::new(|| {\\n    Arc::new(PlatformManager::new().exp\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                              \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try marking as source code\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m//! # Centotype Platform\\n//!\\n//! Platform-specific integrations and optimizations for different operating systems\\n//! and terminal environments. This crate provides:\\n//!\\n//! - Terminal capability detection and optimization\\n//! - OS-specific performance optimizations\\n//! - Cross-platform terminal handling abstractions\\n//! - Hardware detection and feature availability\\n//!\\n//! ## Supported Platforms\\n//!\\n//! - **Linux**: Full support with optimizations for common terminals\\n//! - **macOS**: Native terminal integration with performance tuning\\n//! - **Windows**: Windows Terminal, PowerShell, and cmd.exe support\\n//!\\n//! ## Performance Optimizations\\n//!\\n//! - Terminal-specific render optimizations\\n//! - Platform-native input handling\\n//! - Memory management tuning per OS\\n//! - CPU architecture detection\\n\\npub mod terminal;\\npub mod input;\\npub mod performance;\\npub mod detection;\\n\\n// Re-export main types\\npub use terminal::{TerminalCapabilities, TerminalType, TerminalManager};\\npub use input::{PlatformInput, InputOptimizations};\\npub use performance::{PlatformPerformance, SystemMetrics};\\npub use detection::{PlatformDetector, PlatformInfo, OSType, Architecture};\\n\\nuse centotype_core::types::*;\\nuse std::sync::Arc;\\nuse once_cell::sync::Lazy;\\n\\n/// Main platform manager that coordinates all platform-specific functionality\\npub struct PlatformManager {\\n    info: PlatformInfo,\\n    terminal_caps: TerminalCapabilities,\\n    input_optimizations: InputOptimizations,\\n    performance_settings: PlatformPerformance,\\n}\\n\\nimpl PlatformManager {\\n    pub fn new() -> Result<Self> {\\n        let detector = PlatformDetector::new();\\n        let info = detector.detect_platform()?;\\n        let terminal_caps = detector.detect_terminal_capabilities()?;\\n        let input_optimizations = InputOptimizations::for_platform(&info)?;\\n        let performance_settings = PlatformPerformance::optimize_for_platform(&info)?;\\n\\n        tracing::info!(\\n            \\\"Platform detected: OS={:?}, Terminal={:?}, Arch={:?}\\\",\\n            info.os_type,\\n            terminal_caps.terminal_type,\\n            info.architecture\\n        );\\n\\n        Ok(Self {\\n            info,\\n            terminal_caps,\\n            input_optimizations,\\n            performance_settings,\\n        })\\n    }\\n\\n    pub fn platform_info(&self) -> &PlatformInfo {\\n        &self.info\\n    }\\n\\n    pub fn terminal_capabilities(&self) -> &TerminalCapabilities {\\n        &self.terminal_caps\\n    }\\n\\n    pub fn input_optimizations(&self) -> &InputOptimizations {\\n        &self.input_optimizations\\n    }\\n\\n    pub fn performance_settings(&self) -> &PlatformPerformance {\\n        &self.performance_settings\\n    }\\n\\n    /// Check if the platform meets minimum requirements\\n    pub fn validate_platform(&self) -> PlatformValidation {\\n        let mut issues = Vec::new();\\n        let mut warnings = Vec::new();\\n\\n        // Check terminal capabilities\\n        if !self.terminal_caps.supports_raw_mode {\\n            issues.push(\\\"Terminal does not support raw mode\\\".to_string());\\n        }\\n\\n        if !self.terminal_caps.supports_color {\\n            warnings.push(\\\"Terminal does not support color - using monochrome mode\\\".to_string());\\n        }\\n\\n        // Check performance capabilities\\n        if !self.performance_settings.can_meet_targets {\\n            warnings.push(\\\"Platform may not meet performance targets\\\".to_string());\\n        }\\n\\n        // Check input handling\\n        if !self.input_optimizations.high_precision_timing {\\n            warnings.push(\\\"High precision input timing not available\\\".to_string());\\n        }\\n\\n        PlatformValidation {\\n            is_supported: issues.is_empty(),\\n            issues,\\n            warnings,\\n            recommended_settings: self.get_recommended_settings(),\\n        }\\n    }\\n\\n    fn get_recommended_settings(&self) -> RecommendedSettings {\\n        RecommendedSettings {\\n            use_reduced_effects: !self.performance_settings.can_meet_targets,\\n            buffer_size: self.input_optimizations.recommended_buffer_size,\\n            render_frequency: self.performance_settings.recommended_fps,\\n            memory_limit_mb: self.performance_settings.memory_limit_mb,\\n        }\\n    }\\n\\n    /// Apply platform-specific optimizations\\n    pub fn apply_optimizations(&self) -> Result<()> {\\n        // Apply input optimizations\\n        self.input_optimizations.configure_input_system()?;\\n        \\n        // Apply performance optimizations  \\n        self.performance_settings.configure_performance()?;\\n        \\n        // Configure terminal-specific settings\\n        self.terminal_caps.configure_terminal()?;\\n        \\n        tracing::info!(\\\"Platform optimizations applied successfully\\\");\\n        Ok(())\\n    }\\n\\n    /// Get system resource information\\n    pub fn get_system_metrics(&self) -> SystemMetrics {\\n        self.performance_settings.get_current_metrics()\\n    }\\n\\n    /// Check if graceful degradation is needed\\n    pub fn should_use_fallback_mode(&self) -> bool {\\n        !self.performance_settings.can_meet_targets\\n            || self.terminal_caps.has_limitations()\\n    }\\n\\n    /// Get platform-specific error recovery strategies\\n    pub fn get_error_recovery(&self) -> ErrorRecoveryStrategy {\\n        match self.info.os_type {\\n            OSType::Windows => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: true,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: false,\\n            },\\n            OSType::MacOS | OSType::Linux => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: false,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: true,\\n            },\\n            OSType::Unknown => ErrorRecoveryStrategy::default(),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct PlatformValidation {\\n    pub is_supported: bool,\\n    pub issues: Vec<String>,\\n    pub warnings: Vec<String>,\\n    pub recommended_settings: RecommendedSettings,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct RecommendedSettings {\\n    pub use_reduced_effects: bool,\\n    pub buffer_size: usize,\\n    pub render_frequency: u32,\\n    pub memory_limit_mb: u64,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct ErrorRecoveryStrategy {\\n    pub restore_console_mode: bool,\\n    pub flush_input_buffer: bool,\\n    pub reset_cursor_visibility: bool,\\n    pub clear_screen_on_exit: bool,\\n}\\n\\nimpl Default for ErrorRecoveryStrategy {\\n    fn default() -> Self {\\n        Self {\\n            restore_console_mode: true,\\n            flush_input_buffer: true,\\n            reset_cursor_visibility: true,\\n            clear_screen_on_exit: true,\\n        }\\n    }\\n}\\n\\n/// Global platform manager instance\\nstatic PLATFORM_MANAGER: \u001b[0m\u001b[0m\u001b[38;5;10m`\u001b[0m\u001b[0mLazy<Arc<PlatformManager>>\u001b[0m\u001b[0m\u001b[38;5;10m`\u001b[0m\u001b[0m = Lazy::new(|| {\\n    Arc::new(PlatformManager::new().expect(\\\"Failed to initialize platform manager\\\"))\\n});\\n\\n/// Get the global platform manager instance\\npub fn get_platform_manager() -> Arc<PlatformManager> {\\n    Arc::clone(&PLATFORM_MANAGER)\\n}\\n\\nimpl Default for PlatformManager {\\n    fn default() -> Self {\\n        Self::new().expect(\\\"Failed to create default platform manager\\\")\\n    }\\n}\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unclosed HTML tag `PlatformManager`","code":{"code":"rustdoc::invalid_html_tags","explanation":null},"level":"warning","spans":[{"file_name":"platform/src/lib.rs","byte_start":7151,"byte_end":7168,"line_start":1,"line_end":1,"column_start":7152,"column_end":7169,"is_primary":true,"text":[{"text":"//! # Centotype Platform\\n//!\\n//! Platform-specific integrations and optimizations for different operating systems\\n//! and terminal environments. This crate provides:\\n//!\\n//! - Terminal capability detection and optimization\\n//! - OS-specific performance optimizations\\n//! - Cross-platform terminal handling abstractions\\n//! - Hardware detection and feature availability\\n//!\\n//! ## Supported Platforms\\n//!\\n//! - **Linux**: Full support with optimizations for common terminals\\n//! - **macOS**: Native terminal integration with performance tuning\\n//! - **Windows**: Windows Terminal, PowerShell, and cmd.exe support\\n//!\\n//! ## Performance Optimizations\\n//!\\n//! - Terminal-specific render optimizations\\n//! - Platform-native input handling\\n//! - Memory management tuning per OS\\n//! - CPU architecture detection\\n\\npub mod terminal;\\npub mod input;\\npub mod performance;\\npub mod detection;\\n\\n// Re-export main types\\npub use terminal::{TerminalCapabilities, TerminalType, TerminalManager};\\npub use input::{PlatformInput, InputOptimizations};\\npub use performance::{PlatformPerformance, SystemMetrics};\\npub use detection::{PlatformDetector, PlatformInfo, OSType, Architecture};\\n\\nuse centotype_core::types::*;\\nuse std::sync::Arc;\\nuse once_cell::sync::Lazy;\\n\\n/// Main platform manager that coordinates all platform-specific functionality\\npub struct PlatformManager {\\n    info: PlatformInfo,\\n    terminal_caps: TerminalCapabilities,\\n    input_optimizations: InputOptimizations,\\n    performance_settings: PlatformPerformance,\\n}\\n\\nimpl PlatformManager {\\n    pub fn new() -> Result<Self> {\\n        let detector = PlatformDetector::new();\\n        let info = detector.detect_platform()?;\\n        let terminal_caps = detector.detect_terminal_capabilities()?;\\n        let input_optimizations = InputOptimizations::for_platform(&info)?;\\n        let performance_settings = PlatformPerformance::optimize_for_platform(&info)?;\\n\\n        tracing::info!(\\n            \\\"Platform detected: OS={:?}, Terminal={:?}, Arch={:?}\\\",\\n            info.os_type,\\n            terminal_caps.terminal_type,\\n            info.architecture\\n        );\\n\\n        Ok(Self {\\n            info,\\n            terminal_caps,\\n            input_optimizations,\\n            performance_settings,\\n        })\\n    }\\n\\n    pub fn platform_info(&self) -> &PlatformInfo {\\n        &self.info\\n    }\\n\\n    pub fn terminal_capabilities(&self) -> &TerminalCapabilities {\\n        &self.terminal_caps\\n    }\\n\\n    pub fn input_optimizations(&self) -> &InputOptimizations {\\n        &self.input_optimizations\\n    }\\n\\n    pub fn performance_settings(&self) -> &PlatformPerformance {\\n        &self.performance_settings\\n    }\\n\\n    /// Check if the platform meets minimum requirements\\n    pub fn validate_platform(&self) -> PlatformValidation {\\n        let mut issues = Vec::new();\\n        let mut warnings = Vec::new();\\n\\n        // Check terminal capabilities\\n        if !self.terminal_caps.supports_raw_mode {\\n            issues.push(\\\"Terminal does not support raw mode\\\".to_string());\\n        }\\n\\n        if !self.terminal_caps.supports_color {\\n            warnings.push(\\\"Terminal does not support color - using monochrome mode\\\".to_string());\\n        }\\n\\n        // Check performance capabilities\\n        if !self.performance_settings.can_meet_targets {\\n            warnings.push(\\\"Platform may not meet performance targets\\\".to_string());\\n        }\\n\\n        // Check input handling\\n        if !self.input_optimizations.high_precision_timing {\\n            warnings.push(\\\"High precision input timing not available\\\".to_string());\\n        }\\n\\n        PlatformValidation {\\n            is_supported: issues.is_empty(),\\n            issues,\\n            warnings,\\n            recommended_settings: self.get_recommended_settings(),\\n        }\\n    }\\n\\n    fn get_recommended_settings(&self) -> RecommendedSettings {\\n        RecommendedSettings {\\n            use_reduced_effects: !self.performance_settings.can_meet_targets,\\n            buffer_size: self.input_optimizations.recommended_buffer_size,\\n            render_frequency: self.performance_settings.recommended_fps,\\n            memory_limit_mb: self.performance_settings.memory_limit_mb,\\n        }\\n    }\\n\\n    /// Apply platform-specific optimizations\\n    pub fn apply_optimizations(&self) -> Result<()> {\\n        // Apply input optimizations\\n        self.input_optimizations.configure_input_system()?;\\n        \\n        // Apply performance optimizations  \\n        self.performance_settings.configure_performance()?;\\n        \\n        // Configure terminal-specific settings\\n        self.terminal_caps.configure_terminal()?;\\n        \\n        tracing::info!(\\\"Platform optimizations applied successfully\\\");\\n        Ok(())\\n    }\\n\\n    /// Get system resource information\\n    pub fn get_system_metrics(&self) -> SystemMetrics {\\n        self.performance_settings.get_current_metrics()\\n    }\\n\\n    /// Check if graceful degradation is needed\\n    pub fn should_use_fallback_mode(&self) -> bool {\\n        !self.performance_settings.can_meet_targets\\n            || self.terminal_caps.has_limitations()\\n    }\\n\\n    /// Get platform-specific error recovery strategies\\n    pub fn get_error_recovery(&self) -> ErrorRecoveryStrategy {\\n        match self.info.os_type {\\n            OSType::Windows => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: true,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: false,\\n            },\\n            OSType::MacOS | OSType::Linux => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: false,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: true,\\n            },\\n            OSType::Unknown => ErrorRecoveryStrategy::default(),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct PlatformValidation {\\n    pub is_supported: bool,\\n    pub issues: Vec<String>,\\n    pub warnings: Vec<String>,\\n    pub recommended_settings: RecommendedSettings,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct RecommendedSettings {\\n    pub use_reduced_effects: bool,\\n    pub buffer_size: usize,\\n    pub render_frequency: u32,\\n    pub memory_limit_mb: u64,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct ErrorRecoveryStrategy {\\n    pub restore_console_mode: bool,\\n    pub flush_input_buffer: bool,\\n    pub reset_cursor_visibility: bool,\\n    pub clear_screen_on_exit: bool,\\n}\\n\\nimpl Default for ErrorRecoveryStrategy {\\n    fn default() -> Self {\\n        Self {\\n            restore_console_mode: true,\\n            flush_input_buffer: true,\\n            reset_cursor_visibility: true,\\n            clear_screen_on_exit: true,\\n        }\\n    }\\n}\\n\\n/// Global platform manager instance\\nstatic PLATFORM_MANAGER: Lazy<Arc<PlatformManager>> = Lazy::new(|| {\\n    Arc::new(PlatformManager::new().expect(\\\"Failed to initialize platform manager\\\"))\\n});\\n\\n/// Get the global platform manager instance\\npub fn get_platform_manager() -> Arc<PlatformManager> {\\n    Arc::clone(&PLATFORM_MANAGER)\\n}\\n\\nimpl Default for PlatformManager {\\n    fn default() -> Self {\\n        Self::new().expect(\\\"Failed to create default platform manager\\\")\\n    }\\n}","highlight_start":7152,"highlight_end":7169}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"try marking as source code","code":null,"level":"help","spans":[{"file_name":"platform/src/lib.rs","byte_start":7148,"byte_end":7148,"line_start":1,"line_end":1,"column_start":7149,"column_end":7149,"is_primary":true,"text":[{"text":"//! # Centotype Platform\\n//!\\n//! Platform-specific integrations and optimizations for different operating systems\\n//! and terminal environments. This crate provides:\\n//!\\n//! - Terminal capability detection and optimization\\n//! - OS-specific performance optimizations\\n//! - Cross-platform terminal handling abstractions\\n//! - Hardware detection and feature availability\\n//!\\n//! ## Supported Platforms\\n//!\\n//! - **Linux**: Full support with optimizations for common terminals\\n//! - **macOS**: Native terminal integration with performance tuning\\n//! - **Windows**: Windows Terminal, PowerShell, and cmd.exe support\\n//!\\n//! ## Performance Optimizations\\n//!\\n//! - Terminal-specific render optimizations\\n//! - Platform-native input handling\\n//! - Memory management tuning per OS\\n//! - CPU architecture detection\\n\\npub mod terminal;\\npub mod input;\\npub mod performance;\\npub mod detection;\\n\\n// Re-export main types\\npub use terminal::{TerminalCapabilities, TerminalType, TerminalManager};\\npub use input::{PlatformInput, InputOptimizations};\\npub use performance::{PlatformPerformance, SystemMetrics};\\npub use detection::{PlatformDetector, PlatformInfo, OSType, Architecture};\\n\\nuse centotype_core::types::*;\\nuse std::sync::Arc;\\nuse once_cell::sync::Lazy;\\n\\n/// Main platform manager that coordinates all platform-specific functionality\\npub struct PlatformManager {\\n    info: PlatformInfo,\\n    terminal_caps: TerminalCapabilities,\\n    input_optimizations: InputOptimizations,\\n    performance_settings: PlatformPerformance,\\n}\\n\\nimpl PlatformManager {\\n    pub fn new() -> Result<Self> {\\n        let detector = PlatformDetector::new();\\n        let info = detector.detect_platform()?;\\n        let terminal_caps = detector.detect_terminal_capabilities()?;\\n        let input_optimizations = InputOptimizations::for_platform(&info)?;\\n        let performance_settings = PlatformPerformance::optimize_for_platform(&info)?;\\n\\n        tracing::info!(\\n            \\\"Platform detected: OS={:?}, Terminal={:?}, Arch={:?}\\\",\\n            info.os_type,\\n            terminal_caps.terminal_type,\\n            info.architecture\\n        );\\n\\n        Ok(Self {\\n            info,\\n            terminal_caps,\\n            input_optimizations,\\n            performance_settings,\\n        })\\n    }\\n\\n    pub fn platform_info(&self) -> &PlatformInfo {\\n        &self.info\\n    }\\n\\n    pub fn terminal_capabilities(&self) -> &TerminalCapabilities {\\n        &self.terminal_caps\\n    }\\n\\n    pub fn input_optimizations(&self) -> &InputOptimizations {\\n        &self.input_optimizations\\n    }\\n\\n    pub fn performance_settings(&self) -> &PlatformPerformance {\\n        &self.performance_settings\\n    }\\n\\n    /// Check if the platform meets minimum requirements\\n    pub fn validate_platform(&self) -> PlatformValidation {\\n        let mut issues = Vec::new();\\n        let mut warnings = Vec::new();\\n\\n        // Check terminal capabilities\\n        if !self.terminal_caps.supports_raw_mode {\\n            issues.push(\\\"Terminal does not support raw mode\\\".to_string());\\n        }\\n\\n        if !self.terminal_caps.supports_color {\\n            warnings.push(\\\"Terminal does not support color - using monochrome mode\\\".to_string());\\n        }\\n\\n        // Check performance capabilities\\n        if !self.performance_settings.can_meet_targets {\\n            warnings.push(\\\"Platform may not meet performance targets\\\".to_string());\\n        }\\n\\n        // Check input handling\\n        if !self.input_optimizations.high_precision_timing {\\n            warnings.push(\\\"High precision input timing not available\\\".to_string());\\n        }\\n\\n        PlatformValidation {\\n            is_supported: issues.is_empty(),\\n            issues,\\n            warnings,\\n            recommended_settings: self.get_recommended_settings(),\\n        }\\n    }\\n\\n    fn get_recommended_settings(&self) -> RecommendedSettings {\\n        RecommendedSettings {\\n            use_reduced_effects: !self.performance_settings.can_meet_targets,\\n            buffer_size: self.input_optimizations.recommended_buffer_size,\\n            render_frequency: self.performance_settings.recommended_fps,\\n            memory_limit_mb: self.performance_settings.memory_limit_mb,\\n        }\\n    }\\n\\n    /// Apply platform-specific optimizations\\n    pub fn apply_optimizations(&self) -> Result<()> {\\n        // Apply input optimizations\\n        self.input_optimizations.configure_input_system()?;\\n        \\n        // Apply performance optimizations  \\n        self.performance_settings.configure_performance()?;\\n        \\n        // Configure terminal-specific settings\\n        self.terminal_caps.configure_terminal()?;\\n        \\n        tracing::info!(\\\"Platform optimizations applied successfully\\\");\\n        Ok(())\\n    }\\n\\n    /// Get system resource information\\n    pub fn get_system_metrics(&self) -> SystemMetrics {\\n        self.performance_settings.get_current_metrics()\\n    }\\n\\n    /// Check if graceful degradation is needed\\n    pub fn should_use_fallback_mode(&self) -> bool {\\n        !self.performance_settings.can_meet_targets\\n            || self.terminal_caps.has_limitations()\\n    }\\n\\n    /// Get platform-specific error recovery strategies\\n    pub fn get_error_recovery(&self) -> ErrorRecoveryStrategy {\\n        match self.info.os_type {\\n            OSType::Windows => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: true,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: false,\\n            },\\n            OSType::MacOS | OSType::Linux => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: false,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: true,\\n            },\\n            OSType::Unknown => ErrorRecoveryStrategy::default(),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct PlatformValidation {\\n    pub is_supported: bool,\\n    pub issues: Vec<String>,\\n    pub warnings: Vec<String>,\\n    pub recommended_settings: RecommendedSettings,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct RecommendedSettings {\\n    pub use_reduced_effects: bool,\\n    pub buffer_size: usize,\\n    pub render_frequency: u32,\\n    pub memory_limit_mb: u64,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct ErrorRecoveryStrategy {\\n    pub restore_console_mode: bool,\\n    pub flush_input_buffer: bool,\\n    pub reset_cursor_visibility: bool,\\n    pub clear_screen_on_exit: bool,\\n}\\n\\nimpl Default for ErrorRecoveryStrategy {\\n    fn default() -> Self {\\n        Self {\\n            restore_console_mode: true,\\n            flush_input_buffer: true,\\n            reset_cursor_visibility: true,\\n            clear_screen_on_exit: true,\\n        }\\n    }\\n}\\n\\n/// Global platform manager instance\\nstatic PLATFORM_MANAGER: Lazy<Arc<PlatformManager>> = Lazy::new(|| {\\n    Arc::new(PlatformManager::new().expect(\\\"Failed to initialize platform manager\\\"))\\n});\\n\\n/// Get the global platform manager instance\\npub fn get_platform_manager() -> Arc<PlatformManager> {\\n    Arc::clone(&PLATFORM_MANAGER)\\n}\\n\\nimpl Default for PlatformManager {\\n    fn default() -> Self {\\n        Self::new().expect(\\\"Failed to create default platform manager\\\")\\n    }\\n}","highlight_start":7149,"highlight_end":7149}],"label":null,"suggested_replacement":"`","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"platform/src/lib.rs","byte_start":7168,"byte_end":7168,"line_start":1,"line_end":1,"column_start":7169,"column_end":7169,"is_primary":true,"text":[{"text":"//! # Centotype Platform\\n//!\\n//! Platform-specific integrations and optimizations for different operating systems\\n//! and terminal environments. This crate provides:\\n//!\\n//! - Terminal capability detection and optimization\\n//! - OS-specific performance optimizations\\n//! - Cross-platform terminal handling abstractions\\n//! - Hardware detection and feature availability\\n//!\\n//! ## Supported Platforms\\n//!\\n//! - **Linux**: Full support with optimizations for common terminals\\n//! - **macOS**: Native terminal integration with performance tuning\\n//! - **Windows**: Windows Terminal, PowerShell, and cmd.exe support\\n//!\\n//! ## Performance Optimizations\\n//!\\n//! - Terminal-specific render optimizations\\n//! - Platform-native input handling\\n//! - Memory management tuning per OS\\n//! - CPU architecture detection\\n\\npub mod terminal;\\npub mod input;\\npub mod performance;\\npub mod detection;\\n\\n// Re-export main types\\npub use terminal::{TerminalCapabilities, TerminalType, TerminalManager};\\npub use input::{PlatformInput, InputOptimizations};\\npub use performance::{PlatformPerformance, SystemMetrics};\\npub use detection::{PlatformDetector, PlatformInfo, OSType, Architecture};\\n\\nuse centotype_core::types::*;\\nuse std::sync::Arc;\\nuse once_cell::sync::Lazy;\\n\\n/// Main platform manager that coordinates all platform-specific functionality\\npub struct PlatformManager {\\n    info: PlatformInfo,\\n    terminal_caps: TerminalCapabilities,\\n    input_optimizations: InputOptimizations,\\n    performance_settings: PlatformPerformance,\\n}\\n\\nimpl PlatformManager {\\n    pub fn new() -> Result<Self> {\\n        let detector = PlatformDetector::new();\\n        let info = detector.detect_platform()?;\\n        let terminal_caps = detector.detect_terminal_capabilities()?;\\n        let input_optimizations = InputOptimizations::for_platform(&info)?;\\n        let performance_settings = PlatformPerformance::optimize_for_platform(&info)?;\\n\\n        tracing::info!(\\n            \\\"Platform detected: OS={:?}, Terminal={:?}, Arch={:?}\\\",\\n            info.os_type,\\n            terminal_caps.terminal_type,\\n            info.architecture\\n        );\\n\\n        Ok(Self {\\n            info,\\n            terminal_caps,\\n            input_optimizations,\\n            performance_settings,\\n        })\\n    }\\n\\n    pub fn platform_info(&self) -> &PlatformInfo {\\n        &self.info\\n    }\\n\\n    pub fn terminal_capabilities(&self) -> &TerminalCapabilities {\\n        &self.terminal_caps\\n    }\\n\\n    pub fn input_optimizations(&self) -> &InputOptimizations {\\n        &self.input_optimizations\\n    }\\n\\n    pub fn performance_settings(&self) -> &PlatformPerformance {\\n        &self.performance_settings\\n    }\\n\\n    /// Check if the platform meets minimum requirements\\n    pub fn validate_platform(&self) -> PlatformValidation {\\n        let mut issues = Vec::new();\\n        let mut warnings = Vec::new();\\n\\n        // Check terminal capabilities\\n        if !self.terminal_caps.supports_raw_mode {\\n            issues.push(\\\"Terminal does not support raw mode\\\".to_string());\\n        }\\n\\n        if !self.terminal_caps.supports_color {\\n            warnings.push(\\\"Terminal does not support color - using monochrome mode\\\".to_string());\\n        }\\n\\n        // Check performance capabilities\\n        if !self.performance_settings.can_meet_targets {\\n            warnings.push(\\\"Platform may not meet performance targets\\\".to_string());\\n        }\\n\\n        // Check input handling\\n        if !self.input_optimizations.high_precision_timing {\\n            warnings.push(\\\"High precision input timing not available\\\".to_string());\\n        }\\n\\n        PlatformValidation {\\n            is_supported: issues.is_empty(),\\n            issues,\\n            warnings,\\n            recommended_settings: self.get_recommended_settings(),\\n        }\\n    }\\n\\n    fn get_recommended_settings(&self) -> RecommendedSettings {\\n        RecommendedSettings {\\n            use_reduced_effects: !self.performance_settings.can_meet_targets,\\n            buffer_size: self.input_optimizations.recommended_buffer_size,\\n            render_frequency: self.performance_settings.recommended_fps,\\n            memory_limit_mb: self.performance_settings.memory_limit_mb,\\n        }\\n    }\\n\\n    /// Apply platform-specific optimizations\\n    pub fn apply_optimizations(&self) -> Result<()> {\\n        // Apply input optimizations\\n        self.input_optimizations.configure_input_system()?;\\n        \\n        // Apply performance optimizations  \\n        self.performance_settings.configure_performance()?;\\n        \\n        // Configure terminal-specific settings\\n        self.terminal_caps.configure_terminal()?;\\n        \\n        tracing::info!(\\\"Platform optimizations applied successfully\\\");\\n        Ok(())\\n    }\\n\\n    /// Get system resource information\\n    pub fn get_system_metrics(&self) -> SystemMetrics {\\n        self.performance_settings.get_current_metrics()\\n    }\\n\\n    /// Check if graceful degradation is needed\\n    pub fn should_use_fallback_mode(&self) -> bool {\\n        !self.performance_settings.can_meet_targets\\n            || self.terminal_caps.has_limitations()\\n    }\\n\\n    /// Get platform-specific error recovery strategies\\n    pub fn get_error_recovery(&self) -> ErrorRecoveryStrategy {\\n        match self.info.os_type {\\n            OSType::Windows => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: true,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: false,\\n            },\\n            OSType::MacOS | OSType::Linux => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: false,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: true,\\n            },\\n            OSType::Unknown => ErrorRecoveryStrategy::default(),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct PlatformValidation {\\n    pub is_supported: bool,\\n    pub issues: Vec<String>,\\n    pub warnings: Vec<String>,\\n    pub recommended_settings: RecommendedSettings,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct RecommendedSettings {\\n    pub use_reduced_effects: bool,\\n    pub buffer_size: usize,\\n    pub render_frequency: u32,\\n    pub memory_limit_mb: u64,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct ErrorRecoveryStrategy {\\n    pub restore_console_mode: bool,\\n    pub flush_input_buffer: bool,\\n    pub reset_cursor_visibility: bool,\\n    pub clear_screen_on_exit: bool,\\n}\\n\\nimpl Default for ErrorRecoveryStrategy {\\n    fn default() -> Self {\\n        Self {\\n            restore_console_mode: true,\\n            flush_input_buffer: true,\\n            reset_cursor_visibility: true,\\n            clear_screen_on_exit: true,\\n        }\\n    }\\n}\\n\\n/// Global platform manager instance\\nstatic PLATFORM_MANAGER: Lazy<Arc<PlatformManager>> = Lazy::new(|| {\\n    Arc::new(PlatformManager::new().expect(\\\"Failed to initialize platform manager\\\"))\\n});\\n\\n/// Get the global platform manager instance\\npub fn get_platform_manager() -> Arc<PlatformManager> {\\n    Arc::clone(&PLATFORM_MANAGER)\\n}\\n\\nimpl Default for PlatformManager {\\n    fn default() -> Self {\\n        Self::new().expect(\\\"Failed to create default platform manager\\\")\\n    }\\n}","highlight_start":7169,"highlight_end":7169}],"label":null,"suggested_replacement":"`","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unclosed HTML tag `PlatformManager`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mplatform/src/lib.rs:1:7152\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0morm manager instance\\npub fn get_platform_manager() -> Arc<PlatformManager> {\\n    Arc::clone(&PLATFORM_MANAGER)\\n}\\n\\nimpl Default fo\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                              \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: try marking as source code\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m//! # Centotype Platform\\n//!\\n//! Platform-specific integrations and optimizations for different operating systems\\n//! and terminal environments. This crate provides:\\n//!\\n//! - Terminal capability detection and optimization\\n//! - OS-specific performance optimizations\\n//! - Cross-platform terminal handling abstractions\\n//! - Hardware detection and feature availability\\n//!\\n//! ## Supported Platforms\\n//!\\n//! - **Linux**: Full support with optimizations for common terminals\\n//! - **macOS**: Native terminal integration with performance tuning\\n//! - **Windows**: Windows Terminal, PowerShell, and cmd.exe support\\n//!\\n//! ## Performance Optimizations\\n//!\\n//! - Terminal-specific render optimizations\\n//! - Platform-native input handling\\n//! - Memory management tuning per OS\\n//! - CPU architecture detection\\n\\npub mod terminal;\\npub mod input;\\npub mod performance;\\npub mod detection;\\n\\n// Re-export main types\\npub use terminal::{TerminalCapabilities, TerminalType, TerminalManager};\\npub use input::{PlatformInput, InputOptimizations};\\npub use performance::{PlatformPerformance, SystemMetrics};\\npub use detection::{PlatformDetector, PlatformInfo, OSType, Architecture};\\n\\nuse centotype_core::types::*;\\nuse std::sync::Arc;\\nuse once_cell::sync::Lazy;\\n\\n/// Main platform manager that coordinates all platform-specific functionality\\npub struct PlatformManager {\\n    info: PlatformInfo,\\n    terminal_caps: TerminalCapabilities,\\n    input_optimizations: InputOptimizations,\\n    performance_settings: PlatformPerformance,\\n}\\n\\nimpl PlatformManager {\\n    pub fn new() -> Result<Self> {\\n        let detector = PlatformDetector::new();\\n        let info = detector.detect_platform()?;\\n        let terminal_caps = detector.detect_terminal_capabilities()?;\\n        let input_optimizations = InputOptimizations::for_platform(&info)?;\\n        let performance_settings = PlatformPerformance::optimize_for_platform(&info)?;\\n\\n        tracing::info!(\\n            \\\"Platform detected: OS={:?}, Terminal={:?}, Arch={:?}\\\",\\n            info.os_type,\\n            terminal_caps.terminal_type,\\n            info.architecture\\n        );\\n\\n        Ok(Self {\\n            info,\\n            terminal_caps,\\n            input_optimizations,\\n            performance_settings,\\n        })\\n    }\\n\\n    pub fn platform_info(&self) -> &PlatformInfo {\\n        &self.info\\n    }\\n\\n    pub fn terminal_capabilities(&self) -> &TerminalCapabilities {\\n        &self.terminal_caps\\n    }\\n\\n    pub fn input_optimizations(&self) -> &InputOptimizations {\\n        &self.input_optimizations\\n    }\\n\\n    pub fn performance_settings(&self) -> &PlatformPerformance {\\n        &self.performance_settings\\n    }\\n\\n    /// Check if the platform meets minimum requirements\\n    pub fn validate_platform(&self) -> PlatformValidation {\\n        let mut issues = Vec::new();\\n        let mut warnings = Vec::new();\\n\\n        // Check terminal capabilities\\n        if !self.terminal_caps.supports_raw_mode {\\n            issues.push(\\\"Terminal does not support raw mode\\\".to_string());\\n        }\\n\\n        if !self.terminal_caps.supports_color {\\n            warnings.push(\\\"Terminal does not support color - using monochrome mode\\\".to_string());\\n        }\\n\\n        // Check performance capabilities\\n        if !self.performance_settings.can_meet_targets {\\n            warnings.push(\\\"Platform may not meet performance targets\\\".to_string());\\n        }\\n\\n        // Check input handling\\n        if !self.input_optimizations.high_precision_timing {\\n            warnings.push(\\\"High precision input timing not available\\\".to_string());\\n        }\\n\\n        PlatformValidation {\\n            is_supported: issues.is_empty(),\\n            issues,\\n            warnings,\\n            recommended_settings: self.get_recommended_settings(),\\n        }\\n    }\\n\\n    fn get_recommended_settings(&self) -> RecommendedSettings {\\n        RecommendedSettings {\\n            use_reduced_effects: !self.performance_settings.can_meet_targets,\\n            buffer_size: self.input_optimizations.recommended_buffer_size,\\n            render_frequency: self.performance_settings.recommended_fps,\\n            memory_limit_mb: self.performance_settings.memory_limit_mb,\\n        }\\n    }\\n\\n    /// Apply platform-specific optimizations\\n    pub fn apply_optimizations(&self) -> Result<()> {\\n        // Apply input optimizations\\n        self.input_optimizations.configure_input_system()?;\\n        \\n        // Apply performance optimizations  \\n        self.performance_settings.configure_performance()?;\\n        \\n        // Configure terminal-specific settings\\n        self.terminal_caps.configure_terminal()?;\\n        \\n        tracing::info!(\\\"Platform optimizations applied successfully\\\");\\n        Ok(())\\n    }\\n\\n    /// Get system resource information\\n    pub fn get_system_metrics(&self) -> SystemMetrics {\\n        self.performance_settings.get_current_metrics()\\n    }\\n\\n    /// Check if graceful degradation is needed\\n    pub fn should_use_fallback_mode(&self) -> bool {\\n        !self.performance_settings.can_meet_targets\\n            || self.terminal_caps.has_limitations()\\n    }\\n\\n    /// Get platform-specific error recovery strategies\\n    pub fn get_error_recovery(&self) -> ErrorRecoveryStrategy {\\n        match self.info.os_type {\\n            OSType::Windows => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: true,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: false,\\n            },\\n            OSType::MacOS | OSType::Linux => ErrorRecoveryStrategy {\\n                restore_console_mode: true,\\n                flush_input_buffer: false,\\n                reset_cursor_visibility: true,\\n                clear_screen_on_exit: true,\\n            },\\n            OSType::Unknown => ErrorRecoveryStrategy::default(),\\n        }\\n    }\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct PlatformValidation {\\n    pub is_supported: bool,\\n    pub issues: Vec<String>,\\n    pub warnings: Vec<String>,\\n    pub recommended_settings: RecommendedSettings,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct RecommendedSettings {\\n    pub use_reduced_effects: bool,\\n    pub buffer_size: usize,\\n    pub render_frequency: u32,\\n    pub memory_limit_mb: u64,\\n}\\n\\n#[derive(Debug, Clone)]\\npub struct ErrorRecoveryStrategy {\\n    pub restore_console_mode: bool,\\n    pub flush_input_buffer: bool,\\n    pub reset_cursor_visibility: bool,\\n    pub clear_screen_on_exit: bool,\\n}\\n\\nimpl Default for ErrorRecoveryStrategy {\\n    fn default() -> Self {\\n        Self {\\n            restore_console_mode: true,\\n            flush_input_buffer: true,\\n            reset_cursor_visibility: true,\\n            clear_screen_on_exit: true,\\n        }\\n    }\\n}\\n\\n/// Global platform manager instance\\nstatic PLATFORM_MANAGER: Lazy<Arc<PlatformManager>> = Lazy::new(|| {\\n    Arc::new(PlatformManager::new().expect(\\\"Failed to initialize platform manager\\\"))\\n});\\n\\n/// Get the global platform manager instance\\npub fn get_platform_manager() -> \u001b[0m\u001b[0m\u001b[38;5;10m`\u001b[0m\u001b[0mArc<PlatformManager>\u001b[0m\u001b[0m\u001b[38;5;10m`\u001b[0m\u001b[0m {\\n    Arc::clone(&PLATFORM_MANAGER)\\n}\\n\\nimpl Default for PlatformManager {\\n    fn default() -> Self {\\n        Self::new().expect(\\\"Failed to create default platform manager\\\")\\n    }\\n}\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\u001b[0m                    \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"5 warnings emitted","code":null,"level":"warning","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: 5 warnings emitted\u001b[0m\n\n"}
